<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agentic FEM - Terminal Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background-color: #000000;
            color: #00ff00;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: grid;
            grid-template-areas: 
                "prompt prompt prompt"
                "left center right";
            grid-template-rows: 100px calc(100vh - 110px);
            grid-template-columns: 200px 1fr 300px;
            height: 100vh;
            gap: 2px;
            padding: 3px;
        }
        
        .prompt-section {
            grid-area: prompt;
            background-color: #001100;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 8px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow: visible;
            min-height: 100px;
            height: 100px;
        }
        
        .prompt-input {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .prompt-label {
            color: #00ff00;
            font-weight: bold;
            white-space: nowrap;
        }
        
        #prompt {
            flex: 1;
            background-color: #000000;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-radius: 3px;
        }
        
        #prompt:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 5px #00ff88;
        }
        
        .submit-btn {
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .submit-btn:hover {
            background-color: #00ff00;
            color: #000000;
        }
        
        .submit-btn:disabled {
            background-color: #001100;
            color: #006600;
            cursor: not-allowed;
        }
        
        .clear-btn {
            background-color: #330000;
            color: #ff6666;
            border: 1px solid #ff6666;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            margin-left: 10px;
        }
        
        .clear-btn:hover {
            background-color: #ff6666;
            color: #000000;
        }
        
        .solve-btn {
            background-color: #003366;
            color: #66ccff;
            border: 1px solid #66ccff;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            margin-top: 10px;
            width: 100%;
        }
        
        .solve-btn:hover {
            background-color: #66ccff;
            color: #000000;
        }
        
        .fill-context-btn {
            background-color: #663300;
            color: #ffcc66;
            border: 1px solid #ffcc66;
            padding: 8px 16px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s ease;
            margin-top: 10px;
            width: 100%;
        }
        
        .fill-context-btn:hover {
            background-color: #ffcc66;
            color: #000000;
        }
        
        
        .examples {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
            background-color: rgba(0, 255, 0, 0.1);
            padding: 5px;
            border-radius: 3px;
            border: 1px solid rgba(0, 255, 0, 0.3);
        }
        
        .examples-label {
            color: #00ff88;
            font-size: 12px;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .example-btn {
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 6px 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            font-weight: bold;
        }
        
        .example-btn:hover {
            background-color: #00ff00;
            color: #000000;
        }
        
        .left-panel {
            grid-area: left;
            background-color: #001100;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
        }
        
        .center-panel {
            grid-area: center;
            background-color: #000000;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 5px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }
        
        #centerContent {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .right-panel {
            grid-area: right;
            background-color: #001100;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
        }
        
        .panel-title {
            color: #00ff88;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 15px;
            text-transform: uppercase;
            border-bottom: 1px solid #00ff00;
            padding-bottom: 5px;
        }
        
        .current-prompt {
            background-color: #002200;
            border: 1px solid #00ff00;
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 15px;
            font-family: 'Courier New', monospace;
        }
        
        .equations {
            margin-bottom: 20px;
        }
        
        .equation {
            background-color: #000000;
            border: 1px solid #00ff00;
            border-radius: 3px;
            padding: 10px;
            margin-bottom: 10px;
            text-align: center;
            font-size: 14px;
        }
        
        .material-properties, .geometry-details, .mesh-details, .boundary-conditions {
            margin-bottom: 20px;
            border: 1px solid #004400;
            border-radius: 5px;
            padding: 10px;
            background-color: #000800;
        }
        
        .context-section {
            margin-bottom: 20px;
            border: 1px solid #004400;
            border-radius: 5px;
            padding: 10px;
            background-color: #000800;
        }
        
        .context-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            padding: 5px;
            border-radius: 3px;
        }
        
        .context-item.missing {
            background-color: #330000;
            border: 1px solid #ff6666;
        }
        
        .context-item:not(.missing) {
            background-color: #003300;
            border: 1px solid #00ff00;
        }
        
        .context-key {
            color: #00ff88;
            font-weight: bold;
            min-width: 120px;
            font-size: 12px;
        }
        
        .context-value {
            flex: 1;
            font-size: 12px;
        }
        
        .boundary-condition-item {
            flex-direction: column;
            align-items: stretch;
        }
        
        .boundary-location {
            margin-bottom: 5px;
        }
        
        .boundary-controls {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        
        .boundary-controls select,
        .boundary-controls input {
            flex: 1;
        }
        
        .btn-remove {
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            min-width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .btn-remove:hover {
            background: #ff6666;
        }
        
        .context-value.complete {
            color: #00ff00;
        }
        
        .context-value.missing {
            color: #ff6666;
        }
        
        .config-input {
            background-color: #001100;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 4px 8px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            border-radius: 3px;
            min-width: 100px;
        }
        
        .config-input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 3px #00ff88;
        }
        
        .config-input::placeholder {
            color: #666666;
        }
        
        
        
        .property-item, .detail-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px;
            background-color: #002200;
            border-radius: 3px;
        }
        
        .property-key, .detail-key {
            color: #00ff88;
            font-weight: bold;
        }
        
        .property-value, .detail-value {
            color: #00ff00;
        }
        
        .visualization-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #000000;
            border: 1px solid #00ff00;
            border-radius: 3px;
            overflow: hidden;
            min-height: 0;
        }
        
        .visualization-header {
            background-color: #002200;
            padding: 5px;
            border-bottom: 1px solid #00ff00;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .visualization-title {
            color: #00ff88;
            font-weight: bold;
        }
        
        .visualization-controls {
            display: flex;
            gap: 10px;
        }
        
        .control-btn {
            background-color: #003300;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 5px 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
        }
        
        .control-btn:hover {
            background-color: #00ff00;
            color: #000000;
        }
        
        .visualization-iframe {
            flex: 1;
            width: 100%;
            height: 100%;
            border: none;
            background-color: #000000;
            overflow: hidden;
            min-height: 0;
        }
        
        .visualization-placeholder {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #000000;
            border: 2px dashed #00ff00;
            border-radius: 5px;
            margin: 10px;
        }
        
        .placeholder-content {
            text-align: center;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        
        .placeholder-content h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }
        
        .placeholder-content p {
            margin-bottom: 15px;
            opacity: 0.8;
        }
        
        .placeholder-examples {
            margin-top: 20px;
            font-size: 0.9em;
            opacity: 0.7;
        }
        
        .placeholder-examples ul {
            list-style: none;
            padding: 0;
        }
        
        .placeholder-examples li {
            margin: 5px 0;
            padding: 3px 0;
            border-bottom: 1px solid #003300;
        }
        
        .status {
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        .status.success {
            background-color: #002200;
            border: 1px solid #00ff00;
            color: #00ff00;
        }
        
        .status.error {
            background-color: #220000;
            border: 1px solid #ff0000;
            color: #ff0000;
        }
        
        .status.info {
            background-color: #002222;
            border: 1px solid #00ffff;
            color: #00ffff;
        }
        
        .loading {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #003300;
            border-top: 2px solid #00ff00;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #001100;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #00ff88;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top: Prompt Section -->
        <div class="prompt-section">
            <div class="prompt-input">
                <span class="prompt-label">PHYSICS_PROMPT> </span>
                <input type="text" id="prompt" placeholder="Enter physics simulation prompt...">
                <button class="submit-btn" id="submitBtn" onclick="simulate()">SUBMIT</button>
                <button class="clear-btn" id="clearBtn" onclick="clearContext()">CLEAR CONTEXT</button>
            </div>
            <div class="examples">
                <span class="examples-label">Examples:</span>
                <button class="example-btn" onclick="useExample('heat transfer in copper wire, 1m long, diameter 60cm, 100°C at one end, 10°C at other end')">Heat Transfer</button>
                <button class="example-btn" onclick="useExample('stress in steel beam, 2mx3mx1m, with 1000N load at one end and fixed on other end')">Solid Mechanics</button>
            </div>
        </div>
        
        <!-- Left: Current Prompt & Equations -->
        <div class="left-panel">
            <div class="panel-title">Current Prompt & Equations</div>
            <div id="leftContent">
                <div class="status info">
                    Ready for physics simulation input...
                </div>
            </div>
        </div>
        
        <!-- Center: 3D Mesh Visualization -->
        <div class="center-panel">
            <div class="panel-title"> 3D Mesh Visualization</div>
            <div id="centerContent">
                <div class="visualization-container">
                    <div class="visualization-header">
                        <div class="visualization-controls hidden" id="vizControls">
                            <button class="control-btn" onclick="openFullScreen()">Full Screen</button>
                            <button class="control-btn" onclick="toggleSize()">Toggle Size</button>
                        </div>
                    </div>
                    <div style="flex: 1; display: flex; align-items: center; justify-content: center; color: #006600;">
                        <div style="text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 20px;">3D</div>
                            <div>3D Mesh visualization will appear here</div>
                            <div style="font-size: 12px; margin-top: 10px; color: #004400;">Submit a physics prompt to generate mesh</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Right: Material Properties & Geometry -->
        <div class="right-panel">
            <div class="panel-title"> Properties & Geometry</div>
            <div id="rightContent">
                <div class="status info">
                    Material properties, geometry details, and mesh parameters will be displayed here...
                </div>
            </div>
        </div>
    </div>
    
    <!-- MathJax for equation rendering -->
    <!-- No external dependencies needed -->
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    
    <script>
        let currentVisualizationUrl = null;
        
        // Diagnostic: Log current page URL on load
        console.log('=== PAGE LOADED (v2.1 - Fixed URLs) ===');
        console.log('Current URL:', window.location.href);
        console.log('Origin:', window.location.origin);
        console.log('Host:', window.location.host);
        console.log('Protocol:', window.location.protocol);
        
        // Test URL construction
        const testOrigin = window.location.protocol + '//' + window.location.host;
        console.log('Test Origin (constructed):', testOrigin);
        console.log('Origin match:', testOrigin === window.location.origin);
        
        // Warn if accessing via localhost but expecting AWS
        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
            console.warn('WARNING: You are accessing the application via localhost!');
            console.warn('Make sure you are accessing through the AWS public IP or domain.');
            console.warn('Expected format: http://<AWS_IP>:8080');
        }
        
        function useExample(prompt) {
            document.getElementById('prompt').value = prompt;
        }
        
        async function simulate() {
            const prompt = document.getElementById('prompt').value.trim();
            const submitBtn = document.getElementById('submitBtn');
            
            if (!prompt) {
                showStatus('error', 'Please enter a physics simulation prompt');
                return;
            }
            
            // Show loading state
            submitBtn.textContent = 'PROCESSING...';
            submitBtn.disabled = true;
            
            // Clear previous results
            clearResults();
            showLoading();
            showStatus('info', 'Sending prompt to server...');
            
            try {
                // Use absolute URL based on current page location - explicit construction
                const origin = window.location.protocol + '//' + window.location.host;
                const apiUrl = origin + '/simulation/parse';
                
                console.log('=== SENDING PARSE REQUEST ===');
                console.log('Prompt:', prompt);
                console.log('Current page URL:', window.location.href);
                console.log('Protocol:', window.location.protocol);
                console.log('Host:', window.location.host);
                console.log('Origin (constructed):', origin);
                console.log('API URL:', apiUrl);
                
                // Validate URL before using
                if (!apiUrl.startsWith('http://') && !apiUrl.startsWith('https://')) {
                    throw new Error('Invalid API URL: ' + apiUrl);
                }
                
                // CRITICAL: Send current context to preserve UI modifications
                // When prompt is changed and resubmitted:
                // 1. The new prompt is used for parsing
                // 2. UI inputs in the right panel take precedence over parsed results
                // 3. Merged context reflects both new prompt parsing and preserved UI modifications
                const currentContextForParse = window.currentContext || {};
                
                // Mark boundary conditions as user-modified if they exist
                // This ensures UI inputs take precedence over parsed results
                const contextWithUserFlags = { ...currentContextForParse };
                if (contextWithUserFlags.boundary_conditions && Array.isArray(contextWithUserFlags.boundary_conditions)) {
                    contextWithUserFlags.boundary_conditions = contextWithUserFlags.boundary_conditions.map(bc => {
                        if (typeof bc === 'object' && bc !== null) {
                            // Mark as user-modified if it's not already a placeholder
                            if (bc.source !== 'placeholder' && !bc.is_placeholder) {
                                return { ...bc, source: 'user', is_user_modified: true };
                            }
                            return bc;
                        }
                        return bc;
                    });
                }
                
                console.log('=== PARSE REQUEST: Preserving UI Inputs ===');
                console.log('New prompt:', prompt);
                console.log('Current context with UI modifications:', contextWithUserFlags);
                console.log('UI inputs will take precedence over parsed results');
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        context: contextWithUserFlags  // Send current context to preserve UI inputs
                    })
                });
                
                console.log('Response status:', response.status);
                console.log('Response ok:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    showStatus('error', `Server error: ${response.status} - ${errorText}`);
                    document.getElementById('leftContent').innerHTML = `
                        <div class="status error">
                            <strong>Error ${response.status}</strong><br/>
                            ${errorText.substring(0, 200)}
                        </div>
                    `;
                    return;
                }
                
                showStatus('info', 'Processing response...');
                const data = await response.json();
                console.log('=== PARSE RESPONSE ===');
                console.log('Full response:', data);
                console.log('Success:', data.success);
                console.log('Action:', data.action);
                
                if (data.success) {
                    showStatus('success', 'Prompt parsed successfully!');
                    
                    // Store the simulation data for later PDE solving
                    window.currentSimulationData = data;
                    
                    // displayResults will merge the parsed context with existing UI context
                    // UI inputs take precedence over parsed results
                    displayResults(data, prompt);
                    
                    // Debug: Log the merged context structure
                    console.log('Merged context structure:', window.currentContext);
                    console.log('Boundary conditions in merged context:', window.currentContext?.boundary_conditions);
                } else {
                    showStatus('error', data.message || 'Failed to parse prompt');
                    document.getElementById('leftContent').innerHTML = `
                        <div class="status error">
                            <strong>Parse Failed</strong><br/>
                            ${data.message || 'Unknown error'}
                        </div>
                    `;
                }
                
            } catch (error) {
                console.error('=== ERROR IN PARSE REQUEST ===');
                console.error('Error type:', error.constructor.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showStatus('error', 'Error processing request: ' + error.message);
            } finally {
                // Always reset the button state, even if request succeeds or fails
                submitBtn.textContent = 'SUBMIT';
                submitBtn.disabled = false;
            }
        }
        
        async function solvePDE() {
            const solveBtn = document.getElementById('solveBtn');
            
            if (!window.currentSimulationData) {
                showStatus('error', 'No simulation data available. Please submit a prompt first.');
                return;
            }
            
            // Show loading state
            solveBtn.textContent = 'SOLVING...';
            solveBtn.disabled = true;
            
            try {
                const requestData = {
                    prompt: document.getElementById('prompt').value,
                    context: window.currentContext  // Use the filled context
                };
                
                // Use absolute URL based on current page location - explicit construction
                const origin = window.location.protocol + '//' + window.location.host;
                const solveUrl = origin + '/simulation/solve';
                
                console.log('=== SENDING SOLVE REQUEST ===');
                console.log('Current page URL:', window.location.href);
                console.log('Origin (constructed):', origin);
                console.log('Solve URL:', solveUrl);
                console.log('Current context being sent:', window.currentContext);
                console.log('Request data:', requestData);
                
                const response = await fetch(solveUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('Solve response status:', response.status);
                console.log('Solve response ok:', response.ok);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Solve error response:', errorText);
                    showStatus('error', `Solve error: ${response.status} - ${errorText}`);
                    return;
                }
                
                const data = await response.json();
                
                // If PDE was solved, show mesh visualization with field data
                console.log('=== PDE SOLVE RESPONSE DEBUG ===');
                console.log('Full response:', data);
                console.log('Field visualization URL:', data.field_visualization_url);
                console.log('Mesh visualization URL:', data.mesh_visualization_url);
                console.log('Response keys:', Object.keys(data));
                console.log('Success:', data.success);
                console.log('Action:', data.action);
                console.log('Message:', data.message);
                
                if (data.success) {
                    if (data.field_visualization_url) {
                        console.log('Displaying field visualization:', data.field_visualization_url);
                        displayFieldVisualization(data.field_visualization_url);
                        showStatus('success', 'PDE solved successfully! Field visualization loaded.');
                    } else if (data.mesh_visualization_url) {
                        console.log('Displaying mesh visualization:', data.mesh_visualization_url);
                        displayMeshVisualization(data.mesh_visualization_url);
                        showStatus('success', 'PDE solved successfully! Mesh visualization loaded.');
                    } else {
                        showStatus('success', 'PDE solved successfully!');
                    }
                } else {
                    showStatus('error', data.message || 'Failed to solve PDE');
                }
                
                // IMPORTANT: Do NOT process any other data from the response
                // The response contains simulation_config which would trigger displayResults
                // We only want to update the field visualization, nothing else
                
            } catch (error) {
                console.error('=== ERROR IN SOLVE REQUEST ===');
                console.error('Error type:', error.constructor.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                showStatus('error', 'Error solving PDE: ' + error.message);
            } finally {
                // Always reset both buttons to ensure UI is in correct state
                solveBtn.textContent = 'SOLVE PDE';
                solveBtn.disabled = false;
                // Also reset the submit button in case it's still stuck from parse
                const submitBtn = document.getElementById('submitBtn');
                if (submitBtn) {
                    submitBtn.textContent = 'SUBMIT';
                    submitBtn.disabled = false;
                }
            }
        }
        
        async function clearContext() {
            // Clear the prompt input
            document.getElementById('prompt').value = '';
            
            // Clear all global variables
            window.currentContext = {};
            window.currentSimulationData = null;
            window.currentVisualizationUrl = null;
            
            // Clear all results and visualizations
            clearResults();
            
            // Clear mesh preview and field visualization
            clearAllVisualizations();
            
            // Clear backend context
            try {
                const response = await fetch(`${window.location.origin}/clear-context`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                const data = await response.json();
                if (data.success) {
                    let cleanupInfo = '';
                    if (data.cleanup_counts) {
                        cleanupInfo += ` (Cleaned ${data.cleanup_counts.total_cleaned} static files)`;
                    }
                    if (data.simulation_cleanup) {
                        const sim = data.simulation_cleanup;
                        if (sim.msh_files_removed > 0) {
                            cleanupInfo += ` (Removed ${sim.msh_files_removed} mesh files)`;
                        }
                        if (sim.visualizer_cache_cleared) {
                            cleanupInfo += ' (Cleared cached mesh data)';
                        }
                    }
                    showStatus('success', 'All context cleared successfully. Ready for new simulation.' + cleanupInfo);
                } else {
                    showStatus('error', 'Error clearing context: ' + data.message);
                }
            } catch (error) {
                console.error('Error clearing context:', error);
                showStatus('error', 'Error clearing context: ' + error.message);
            }
            
            console.log('Context cleared - ready for new simulation');
        }
        
        function clearAllVisualizations() {
            // Clear mesh container and iframe
            const centerContent = document.getElementById('centerContent');
            const meshContainer = document.getElementById('meshContainer');
            
            if (meshContainer) {
                meshContainer.remove();
            }
            
            // Reset center content to initial placeholder
                centerContent.innerHTML = `
                <div class="visualization-container">
                    <div class="visualization-header">
                        <div class="visualization-controls hidden" id="vizControls">
                            <button class="control-btn" onclick="openFullScreen()">Full Screen</button>
                            <button class="control-btn" onclick="toggleSize()">Toggle Size</button>
                        </div>
                    </div>
                    <div style="flex: 1; display: flex; align-items: center; justify-content: center; color: #006600;">
                        <div style="text-align: center;">
                            <div style="font-size: 48px; margin-bottom: 20px;">3D</div>
                            <div>3D Mesh visualization will appear here</div>
                            <div style="font-size: 12px; margin-top: 10px; color: #004400;">Submit a physics prompt to generate mesh</div>
                            </div>
                        </div>
                    </div>
                `;
            }
        
        function clearResults() {
            // Clear left and right panels
            document.getElementById('leftContent').innerHTML = '';
            document.getElementById('rightContent').innerHTML = '';
            
            // Show initial status messages
            document.getElementById('leftContent').innerHTML = `
                <div class="status info">
                    Ready for physics simulation input...
                </div>
            `;
            
            document.getElementById('rightContent').innerHTML = `
                <div class="status info">
                    Material properties, geometry details, and mesh parameters will be displayed here...
                </div>
            `;
        }
        
        function showLoading() {
            document.getElementById('leftContent').innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <span>Processing physics prompt...</span>
                </div>
            `;
            
            document.getElementById('rightContent').innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <span>Generating configuration...</span>
                </div>
            `;
        }
        
        function showStatus(type, message) {
            // Show status in a dedicated status area, not in left panel
            let statusDiv = document.getElementById('statusMessage');
            if (!statusDiv) {
                // Create status div if it doesn't exist
                statusDiv = document.createElement('div');
                statusDiv.id = 'statusMessage';
                statusDiv.style.cssText = `
                    position: fixed;
                    top: 10px;
                    right: 10px;
                    padding: 10px 15px;
                    border-radius: 5px;
                    font-family: 'Courier New', monospace;
                    font-size: 14px;
                    z-index: 1000;
                    max-width: 300px;
                    word-wrap: break-word;
                `;
                document.body.appendChild(statusDiv);
            }
            
            // Set status message with appropriate colors
            const colors = {
                'success': 'background-color: #003300; color: #00ff00; border: 1px solid #00ff00;',
                'error': 'background-color: #330000; color: #ff6666; border: 1px solid #ff6666;',
                'info': 'background-color: #000033; color: #6666ff; border: 1px solid #6666ff;',
                'warning': 'background-color: #333300; color: #ffff00; border: 1px solid #ffff00;'
            };
            
            statusDiv.style.cssText += colors[type] || colors['info'];
            statusDiv.textContent = message;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (statusDiv && statusDiv.parentNode) {
                    statusDiv.parentNode.removeChild(statusDiv);
                }
            }, 5000);
        }
        
        function displayResults(data, prompt) {
            if (data.success) {
                // CRITICAL: When a NEW prompt is parsed, parsed values take precedence
                // This is called when /simulation/parse returns, meaning a NEW prompt was just parsed
                const parsedContext = data.context || data.updated_context || {};
                const existingContext = window.currentContext || {};
                
                // When a new prompt is parsed, use parsed values as the primary source
                // Only preserve UI edits if they don't conflict with parsed values
                // Priority order: NEW PROMPT → UI EDITS → OLD VALUES
                function mergeContextsForNewPrompt(uiContext, parsedContext) {
                    // Start with parsed context as base (NEW PROMPT takes precedence)
                    const merged = { ...parsedContext };
                    
                    console.log('=== MERGING CONTEXTS FOR NEW PROMPT ===');
                    console.log('Parsed context (NEW PROMPT - primary):', parsedContext);
                    console.log('Existing UI context (may contain old values):', uiContext);
                    
                    // For each field, use parsed value if present (NEW PROMPT priority)
                    // Only merge in UI values if parsed doesn't have them or they match
                    
                    // Geometry type: Use parsed value (new prompt has priority)
                    if (parsedContext.geometry_type) {
                        merged.geometry_type = parsedContext.geometry_type;
                        console.log(`Using parsed geometry_type: ${parsedContext.geometry_type}`);
                    } else if (uiContext.geometry_type) {
                        // Fallback to UI if parsed doesn't have it
                        merged.geometry_type = uiContext.geometry_type;
                    }
                    
                    // Geometry dimensions: Use parsed if geometry changed, otherwise merge
                    if (parsedContext.geometry_type && uiContext.geometry_type &&
                        parsedContext.geometry_type.toLowerCase() !== uiContext.geometry_type.toLowerCase()) {
                        // Geometry changed - use parsed dimensions
                        merged.geometry_dimensions = parsedContext.geometry_dimensions || {};
                        console.log('Geometry changed - using parsed dimensions');
                    } else if (parsedContext.geometry_dimensions) {
                        // Same geometry - merge parsed with UI (parsed as base, UI edits on top)
                        merged.geometry_dimensions = { 
                            ...(parsedContext.geometry_dimensions || {}), 
                            ...(uiContext.geometry_dimensions || {})  // UI edits override parsed defaults
                        };
                    } else if (uiContext.geometry_dimensions) {
                        merged.geometry_dimensions = uiContext.geometry_dimensions;
                    }
                    
                    // Physics type: Use parsed value (new prompt has priority)
                    if (parsedContext.physics_type) {
                        merged.physics_type = parsedContext.physics_type;
                        console.log(`Using parsed physics_type: ${parsedContext.physics_type}`);
                    } else if (uiContext.physics_type) {
                        merged.physics_type = uiContext.physics_type;
                    }
                    
                    // Material type: Use parsed value (new prompt has priority)
                    if (parsedContext.material_type) {
                        merged.material_type = parsedContext.material_type;
                        console.log(`Using parsed material_type: ${parsedContext.material_type}`);
                    } else if (uiContext.material_type) {
                        merged.material_type = uiContext.material_type;
                    }
                    
                    // Material properties: Merge parsed with UI (parsed as base, UI edits on top)
                    if (parsedContext.material_properties || uiContext.material_properties) {
                        merged.material_properties = { 
                            ...(parsedContext.material_properties || {}), 
                            ...(uiContext.material_properties || {})  // UI edits override parsed defaults
                        };
                    }
                    
                    // Boundary conditions: Use parsed values (new prompt has priority)
                    // CRITICAL: Filter BCs to only include valid locations for the new geometry
                    if (parsedContext.boundary_conditions && Array.isArray(parsedContext.boundary_conditions)) {
                        // If geometry changed, filter BCs to only valid locations for new geometry
                        let filteredBCs = parsedContext.boundary_conditions;
                        if (merged.geometry_type) {
                            const availableBoundaries = getAvailableBoundariesForGeometry(merged.geometry_type);
                            const availableBoundariesLower = availableBoundaries.map(b => b.toLowerCase());
                            filteredBCs = parsedContext.boundary_conditions.filter(bc => {
                                if (!bc || !bc.location) return false;
                                const location = bc.location.toLowerCase();
                                // Check if location is in available boundaries (case-insensitive)
                                return availableBoundariesLower.includes(location) || 
                                       availableBoundaries.includes(bc.location);
                            });
                            // If filtering removed all BCs, keep the parsed ones (backend will validate)
                            if (filteredBCs.length === 0 && parsedContext.boundary_conditions.length > 0) {
                                console.warn(`All BCs filtered out for geometry ${merged.geometry_type}, keeping original parsed BCs`);
                                filteredBCs = parsedContext.boundary_conditions;
                            } else if (filteredBCs.length < parsedContext.boundary_conditions.length) {
                                console.log(`Filtered ${parsedContext.boundary_conditions.length} BCs to ${filteredBCs.length} valid BCs for geometry ${merged.geometry_type}`);
                            }
                        }
                        merged.boundary_conditions = filteredBCs;
                        console.log(`Using filtered boundary_conditions for ${merged.geometry_type || 'unknown'}: ${filteredBCs.length} BC(s)`);
                    } else if (uiContext.boundary_conditions && Array.isArray(uiContext.boundary_conditions)) {
                        // Fallback to UI if parsed doesn't have BCs
                        // But filter them for the new geometry if geometry changed
                        if (merged.geometry_type && 
                            uiContext.geometry_type && 
                            merged.geometry_type.toLowerCase() !== uiContext.geometry_type.toLowerCase()) {
                            // Geometry changed - filter UI BCs for new geometry
                            const availableBoundaries = getAvailableBoundariesForGeometry(merged.geometry_type);
                            const availableBoundariesLower = availableBoundaries.map(b => b.toLowerCase());
                            const filteredBCs = uiContext.boundary_conditions.filter(bc => {
                                if (!bc || !bc.location) return false;
                                const location = bc.location.toLowerCase();
                                return availableBoundariesLower.includes(location) || 
                                       availableBoundaries.includes(bc.location);
                            });
                            merged.boundary_conditions = filteredBCs.length > 0 ? filteredBCs : [];
                            console.log(`Filtered UI BCs for new geometry ${merged.geometry_type}: ${filteredBCs.length} valid BC(s)`);
                        } else {
                            merged.boundary_conditions = uiContext.boundary_conditions;
                        }
                    }
                    
                    console.log('Merged context (NEW PROMPT values take precedence):', merged);
                    return merged;
                }
                
                // Merge contexts: NEW PROMPT values take precedence
                const mergedContext = mergeContextsForNewPrompt(existingContext, parsedContext);
                
                // Detect if geometry or physics changed for mesh regeneration and PDE config updates
                const geometryChanged = parsedContext.geometry_type && 
                                      existingContext.geometry_type && 
                                      parsedContext.geometry_type.toLowerCase() !== existingContext.geometry_type.toLowerCase();
                const physicsChanged = parsedContext.physics_type && 
                                     existingContext.physics_type && 
                                     parsedContext.physics_type.toLowerCase() !== existingContext.physics_type.toLowerCase();
                
                console.log('Change detection - geometryChanged:', geometryChanged, 
                          'physicsChanged:', physicsChanged);
                
                // Store the merged context
                currentContext = mergedContext;
                window.currentContext = mergedContext;
                
                console.log('Merged context (UI inputs take precedence):', mergedContext);
                console.log('Existing UI context:', existingContext);
                console.log('Parsed context:', parsedContext);
                
                // Update data object with merged context
                const updatedData = { ...data };
                updatedData.context = mergedContext;
                updatedData.updated_context = mergedContext;
                
                // Also update simulation_config.pde_config to match merged context if it exists
                if (updatedData.simulation_config && updatedData.simulation_config.pde_config) {
                    // Update pde_config with merged context values
                    if (mergedContext.geometry_type) {
                        if (!updatedData.simulation_config.pde_config.mesh_parameters) {
                            updatedData.simulation_config.pde_config.mesh_parameters = {};
                        }
                        updatedData.simulation_config.pde_config.mesh_parameters.geometry_type = mergedContext.geometry_type;
                    }
                    if (mergedContext.geometry_dimensions) {
                        if (!updatedData.simulation_config.pde_config.mesh_parameters) {
                            updatedData.simulation_config.pde_config.mesh_parameters = {};
                        }
                        updatedData.simulation_config.pde_config.mesh_parameters.dimensions = mergedContext.geometry_dimensions;
                    }
                    if (mergedContext.physics_type) {
                        updatedData.simulation_config.pde_config.physics_type = mergedContext.physics_type;
                    }
                    if (mergedContext.material_properties) {
                        updatedData.simulation_config.pde_config.material_properties = mergedContext.material_properties;
                    }
                    if (mergedContext.boundary_conditions) {
                        // CRITICAL: Filter BCs to only valid locations for current geometry before setting in pde_config
                        let bcsToSet = mergedContext.boundary_conditions;
                        if (mergedContext.geometry_type && Array.isArray(bcsToSet)) {
                            const availableBoundaries = getAvailableBoundariesForGeometry(mergedContext.geometry_type);
                            const availableBoundariesLower = availableBoundaries.map(b => b.toLowerCase());
                            const filteredBCs = bcsToSet.filter(bc => {
                                if (!bc || !bc.location) return false;
                                const location = bc.location.toLowerCase();
                                return availableBoundariesLower.includes(location) || 
                                       availableBoundaries.includes(bc.location);
                            });
                            if (filteredBCs.length < bcsToSet.length) {
                                console.log(`Filtered BCs for pde_config: ${bcsToSet.length} -> ${filteredBCs.length} valid BCs for geometry ${mergedContext.geometry_type}`);
                                bcsToSet = filteredBCs;
                            }
                        }
                        updatedData.simulation_config.pde_config.boundary_conditions = bcsToSet;
                    }
                }
                
                // If geometry or physics changed, update PDE config from new context
                if (geometryChanged || physicsChanged) {
                    console.log('Geometry or physics changed - updating PDE config from new context');
                    setTimeout(() => {
                        updatePdeConfigFromContext();
                    }, 300);
                }
                
                // Left panel: Current prompt and equations
                displayLeftPanel(updatedData, prompt);
                
                // Right panel: Material properties and geometry
                displayRightPanel(updatedData);
                
                // Center panel: 3D visualization - ONLY if we have a full simulation visualization
                if (data.mesh_visualization_url) {
                    displayMeshVisualization(data.mesh_visualization_url);
                } else if (mergedContext.geometry_type && mergedContext.geometry_dimensions) {
                    // If we have enough geometry info but no full simulation, generate mesh preview
                    // But DON'T clear the existing mesh container - just update it
                    generateMeshPreviewInCenter();
                }
                // If no geometry info, don't touch the center panel - keep existing content
            } else {
                showStatus('error', data.message || 'Simulation failed');
            }
        }
        
        // Check if context is complete enough to run simulation
        function checkContextCompleteness(context) {
            if (!context) return false;
            
            console.log('=== CONTEXT COMPLETENESS CHECK ===');
            console.log('Context:', context);
            
            // Required fields for simulation
            const requiredFields = [
                'physics_type',
                'material_type', 
                'geometry_type',
                'geometry_dimensions',
                'boundary_conditions'
            ];
            
            // Check if all required fields exist and have values
            for (const field of requiredFields) {
                const fieldValue = context[field];
                let isEmpty = false;
                
                if (field === 'geometry_dimensions') {
                    // Special handling for geometry_dimensions - check if it has required dimensions
                    if (!fieldValue || typeof fieldValue !== 'object') {
                        isEmpty = true;
                    } else {
                        // Check if it has the required dimensions for the geometry type
                        const requiredDims = getRequiredDimensionsForGeometry(context.geometry_type || '');
                        const hasRequiredDims = requiredDims.every(dim => 
                            fieldValue[dim] && fieldValue[dim] !== '' && fieldValue[dim] !== null
                        );
                        isEmpty = !hasRequiredDims;
                    }
                } else if (field === 'boundary_conditions') {
                    // Special handling for boundary_conditions - check if it's an array with at least one BC
                    if (!fieldValue || !Array.isArray(fieldValue) || fieldValue.length === 0) {
                        isEmpty = true;
                    }
                } else {
                    // Standard check for other fields
                    isEmpty = !fieldValue || 
                        (typeof fieldValue === 'object' && Object.keys(fieldValue).length === 0) ||
                        (typeof fieldValue === 'string' && fieldValue.trim() === '');
                }
                
                console.log(`Field '${field}':`, fieldValue, 'Empty:', isEmpty);
                
                if (isEmpty) {
                    console.log(`Context incomplete: missing or empty field '${field}'`);
                        return false;
                }
            }
            
            console.log('Context is complete');
            return true;
        }
        
        // Update button visibility based on context completeness
        function updateButtonVisibility() {
            // Check context completeness using window.currentContext
            const context = window.currentContext || {};
            const isComplete = checkContextCompleteness(context);
            
            console.log('=== UPDATING BUTTON VISIBILITY ===');
            console.log('Context completeness:', isComplete);
            console.log('Current context:', context);
            
            // Get the left content panel where buttons are displayed
            const leftContent = document.getElementById('leftContent');
            if (!leftContent) {
                console.warn('Left content panel not found, cannot update button');
                return;
            }
            
            // Check if button already exists
            const fillBtn = document.getElementById('fillContextBtn');
            const solveBtn = document.getElementById('solveBtn');
            
            if (isComplete) {
                // Context is complete - show "Solve PDE" button
                if (fillBtn) {
                    // Replace "Fill in Context" button with "Solve PDE" button
                    fillBtn.outerHTML = '<button class="solve-btn" id="solveBtn" onclick="solvePDE()">SOLVE PDE</button>';
                    console.log('Replaced "Fill in Context" button with "Solve PDE" button');
                } else if (!solveBtn) {
                    // Add "Solve PDE" button if neither button exists
                    const buttonHtml = '<button class="solve-btn" id="solveBtn" onclick="solvePDE()">SOLVE PDE</button>';
                    leftContent.innerHTML += buttonHtml;
                    console.log('Added "Solve PDE" button');
                } else {
                    // Solve button already exists, no change needed
                    console.log('"Solve PDE" button already exists');
                }
            } else {
                // Context is incomplete - show "Fill in Context" button
                if (solveBtn) {
                    // Replace "Solve PDE" button with "Fill in Context" button
                    solveBtn.outerHTML = '<button class="fill-context-btn" id="fillContextBtn" onclick="fillInContext()">FILL IN CONTEXT</button>';
                    console.log('Replaced "Solve PDE" button with "Fill in Context" button');
                } else if (!fillBtn) {
                    // Add "Fill in Context" button if neither button exists
                    const buttonHtml = '<button class="fill-context-btn" id="fillContextBtn" onclick="fillInContext()">FILL IN CONTEXT</button>';
                    leftContent.innerHTML += buttonHtml;
                    console.log('Added "Fill in Context" button');
                } else {
                    // Fill button already exists, no change needed
                    console.log('"Fill in Context" button already exists');
                }
            }
        }
        
        // Fill in missing context with defaults (respecting existing user input)
        async function fillInContext() {
            const fillBtn = document.getElementById('fillContextBtn');
            
            // Show loading state
            fillBtn.textContent = 'FILLING...';
            fillBtn.disabled = true;
            
            try {
                // Get current context
                const currentContext = window.currentContext || {};
                console.log('=== FILL IN CONTEXT DEBUG ===');
                console.log('Current context before filling:', currentContext);
                
                // Fill in missing fields with defaults (only if not already present)
                const filledContext = { ...currentContext };
                const filledFields = [];
                
                // Set default physics type if missing
                if (!filledContext.physics_type) {
                    filledContext.physics_type = 'heat_transfer';
                    filledFields.push('physics type');
                }
                
                // Set default material if missing
                if (!filledContext.material_type) {
                    filledContext.material_type = 'copper';
                    filledFields.push('material');
                }
                
                // Set default geometry if missing
                console.log('Checking geometry_type:', filledContext.geometry_type);
                if (!filledContext.geometry_type || filledContext.geometry_type === '') {
                    console.log('Setting default geometry to rectangle');
                    filledContext.geometry_type = 'rectangle';
                    filledFields.push('geometry type');
                } else {
                    console.log('Geometry type already set:', filledContext.geometry_type);
                }
                
                // Set default dimensions if missing or incomplete
                if (!filledContext.geometry_dimensions || Object.keys(filledContext.geometry_dimensions).length === 0) {
                    const defaultDims = getDefaultDimensionsForGeometry(filledContext.geometry_type);
                    filledContext.geometry_dimensions = defaultDims;
                    filledFields.push('dimensions');
                } else {
                    // Check if dimensions are incomplete for the geometry type
                    const requiredDims = getRequiredDimensionsForGeometry(filledContext.geometry_type);
                    const missingDims = requiredDims.filter(dim => 
                        !filledContext.geometry_dimensions[dim] || 
                        filledContext.geometry_dimensions[dim] === ''
                    );
                    
                    if (missingDims.length > 0) {
                        const defaultDims = getDefaultDimensionsForGeometry(filledContext.geometry_type);
                        // Only fill missing dimensions, keep existing ones
                        for (const dim of missingDims) {
                            filledContext.geometry_dimensions[dim] = defaultDims[dim];
                        }
                        filledFields.push(`missing dimensions: ${missingDims.join(', ')}`);
                    }
                }
                
                // Set default boundary conditions if missing
                if (!filledContext.boundary_conditions || filledContext.boundary_conditions.length === 0) {
                    const physicsType = filledContext.physics_type || 'heat_transfer';
                    const geometryType = filledContext.geometry_type || 'rectangle';
                    filledContext.boundary_conditions = getDefaultBoundaryConditionsForGeometry(geometryType, physicsType);
                    filledFields.push('boundary conditions');
                }
                
                // Update the global context
                window.currentContext = filledContext;
                console.log('Updated context:', window.currentContext);
                
                // Refresh the right panel to show updated context
                refreshRightPanel();
                
                // Update PDE config with filled context
                setTimeout(() => {
                    updatePdeConfigFromContext();
                }, 100);
                
                // Generate mesh preview if we have geometry type and dimensions
                if (filledContext.geometry_type && filledContext.geometry_dimensions) {
                    const hasValidDimensions = Object.keys(filledContext.geometry_dimensions).length > 0 &&
                        Object.values(filledContext.geometry_dimensions).some(val => {
                            if (val === null || val === undefined || val === '' || val === '0') return false;
                            const numVal = typeof val === 'string' ? parseFloat(val.trim()) : val;
                            return !isNaN(numVal) && numVal > 0;
                        });
                    
                    if (hasValidDimensions) {
                        setTimeout(() => {
                            console.log('Auto-generating mesh preview after filling context');
                            generateMeshPreviewInCenter();
                        }, 300);
                    }
                }
                
                // Show success message with details of what was filled
                const filledMessage = filledFields.length > 0 
                    ? `Context filled: ${filledFields.join(', ')}. You can now solve the PDE or modify the values.`
                    : 'Context was already complete. You can now solve the PDE.';
                showStatus('success', filledMessage);
                
                // Update the button to "Solve PDE" since context is now complete
                const fillBtn = document.getElementById('fillContextBtn');
                if (fillBtn) {
                    fillBtn.outerHTML = '<button class="solve-btn" id="solveBtn" onclick="solvePDE()">SOLVE PDE</button>';
                }
                
            } catch (error) {
                console.error('Error filling context:', error);
                showStatus('error', 'Error filling context: ' + error.message);
                
                // Reset button
                fillBtn.textContent = 'FILL IN CONTEXT';
                fillBtn.disabled = false;
            }
        }
        
        // Get required dimensions for a geometry type
        function getRequiredDimensionsForGeometry(geometryType) {
            const dimensionMapping = {
                'line': ['length'],
                'rod': ['length'],
                'bar': ['length'],
                'rectangle': ['length', 'width'],
                'plate': ['length', 'width', 'thickness'],
                'membrane': ['length', 'width'],
                'square': ['length'],
                'disc': ['radius'],
                'cube': ['length'],
                'box': ['length', 'width', 'height'],
                'cylinder': ['radius', 'length'],
                'sphere': ['radius'],
                'beam': ['length', 'width', 'height']
            };
            
            return dimensionMapping[geometryType] || ['length'];
        }

        function getAvailableBoundariesForGeometry(geometryType) {
            const boundaryMapping = {
                'line': ['left', 'right'],
                'rod': ['left', 'right'],
                'bar': ['left', 'right'],
                'rectangle': ['left', 'right', 'top', 'bottom'],
                'plate': ['left', 'right', 'top', 'bottom'],
                'membrane': ['left', 'right', 'top', 'bottom'],
                'square': ['left', 'right', 'top', 'bottom'],
                'disc': ['circumference', 'center'],
                'cube': ['left', 'right', 'top', 'bottom', 'front', 'back'],
                'box': ['left', 'right', 'top', 'bottom', 'front', 'back'],
                'beam': ['left', 'right', 'top', 'bottom', 'front', 'back'],
                'cylinder': ['top', 'bottom', 'curved surface'],
                'sphere': ['surface', 'center']
            };
            const geometryLower = (geometryType || '').toLowerCase();
            return boundaryMapping[geometryLower] || ['left', 'right', 'top', 'bottom'];
        }

        function getDefaultBoundaryConditionsForGeometry(geometryType, physicsType) {
            const boundaries = getAvailableBoundariesForGeometry(geometryType);
            const physics = (physicsType || '').toLowerCase();
            let defaultType = 'free';
            let defaultBcType = 'neumann';
            let defaultValue = 0;
            
            if (physics === 'heat_transfer') {
                defaultType = 'insulated';
            } else if (physics === 'solid_mechanics') {
                defaultType = 'free';
            }
            
            return boundaries.map(boundary => ({
                location: boundary,
                type: defaultType,
                bc_type: defaultBcType,
                value: defaultValue,
                confidence: 0.5,
                source: 'placeholder',
                is_placeholder: true
            }));
        }

        function displayLeftPanel(data, prompt) {
            // Only show content if there's actually a prompt
            if (!prompt || prompt.trim() === '') {
                // Show placeholder if no prompt
                const leftContent = document.getElementById('leftContent');
                if (leftContent) {
                    leftContent.innerHTML = `
                        <div class="status info">
                            Submit a physics simulation prompt to see equations and controls here...
                        </div>
                    `;
                }
                return;
            }
            
            let html = `
                <div class="current-prompt">
                    <strong style="color: #00ff88;">CURRENT PROMPT:</strong><br>
                    ${prompt}
                </div>
            `;
            
            if (data.simulation_config && data.simulation_config.pde_config) {
                const pde = data.simulation_config.pde_config;
                
                if (pde.equations && pde.equations.length > 0) {
                    html += '<div class="equations">';
                    html += '<div style="color: #00ff88; margin-bottom: 10px; font-weight: bold;">GOVERNING EQUATIONS:</div>';
                    
                    pde.equations.forEach((eq, index) => {
                        html += `<div class="equation">$$${eq}$$</div>`;
                    });
                    
                    html += '</div>';
                }
            }
            
            // Add appropriate button based on context completeness (always show buttons after prompt)
            const isContextComplete = checkContextCompleteness(data.context);
            console.log('Context completeness check:', isContextComplete, 'Context:', data.context);
            
            if (isContextComplete) {
                html += '<button class="solve-btn" id="solveBtn" onclick="solvePDE()">SOLVE PDE</button>';
            } else {
                // Always show "Fill in Context" button after prompt submission
                // This allows users to fill in any missing context regardless of how much was parsed
                html += '<button class="fill-context-btn" id="fillContextBtn" onclick="fillInContext()">FILL IN CONTEXT</button>';
            }
            
            document.getElementById('leftContent').innerHTML = html;
            
            // Re-render MathJax
            if (window.MathJax) {
                MathJax.typesetPromise();
            }
        }
        
        function displayRightPanel(data) {
            // Show placeholder if no context or empty context
            if (!data.context || Object.keys(data.context).length === 0) {
                const rightContent = document.getElementById('rightContent');
                if (rightContent) {
                    rightContent.innerHTML = `
                        <div class="status info">
                            Material properties, geometry details, and mesh parameters will be displayed here...
                        </div>
                    `;
                }
                return;
            }
            
            let html = '';
            
            // Show context information and missing fields
            if (data.context) {
                html += '<div class="context-section">';
                html += '<div style="color: #00ff88; margin-bottom: 10px; font-weight: bold;">SIMULATION CONTEXT:</div>';
                
                // Physics Type
                if (data.context.physics_type) {
                    html += `
                        <div class="context-item">
                            <span class="context-key">Physics Type:</span>
                            <span class="context-value complete">${data.context.physics_type.replace('_', ' ').toUpperCase()}</span>
                        </div>
                    `;
                } else {
                    html += `
                        <div class="context-item missing">
                            <span class="context-key">Physics Type:</span>
                            <span class="context-value">MISSING - Specify physics simulation type</span>
                        </div>
                    `;
                }
                
                // Material Type
                html += `
                    <div class="context-item">
                        <span class="context-key">Material:</span>
                        <input type="text" class="config-input" value="${data.context.material_type || ''}" placeholder="e.g., steel, aluminum" onchange="updateConfig('material_type', this.value)">
                    </div>
                `;
                
                // Geometry Type
                html += `
                    <div class="context-item">
                        <span class="context-key">Geometry:</span>
                        <input id="geometryTypeInput" type="text" class="config-input" value="${data.context.geometry_type || ''}" placeholder="e.g., beam, plate, cylinder" onchange="(updateConfig('geometry_type', this.value), classifyAndSetGeometry(this.value))">
                    </div>
                `;
                
                // Dimensions - Dynamic based on geometry type
                html += '<div class="dimensions-section">';
                html += '<div style="color: #00ff88; margin: 10px 0 5px 0; font-weight: bold;">DIMENSIONS:</div>';
                
                const geometryType = data.context.geometry_type || 'beam';
                const currentDimensions = data.context.geometry_dimensions || {};
                
                // Define dimension fields based on geometry type
                // Async render from dimension spec
                html += '<div id="dynamic-dimensions"></div>';
                
                html += '</div>';
                
                // Boundary Conditions
                html += '<div class="boundary-conditions-section">';
                html += '<div style="color: #00ff88; margin: 10px 0 5px 0; font-weight: bold;">BOUNDARY CONDITIONS:</div>';
                
                // Debug: Log boundary conditions structure (with safe access)
                console.log('=== BOUNDARY CONDITIONS DEBUG ===');
                console.log('data:', data);
                console.log('data.context:', data.context);
                if (data.context) {
                    console.log('data.context.boundary_conditions:', data.context.boundary_conditions);
                    console.log('Type:', typeof data.context.boundary_conditions);
                    console.log('Is array:', Array.isArray(data.context.boundary_conditions));
                    console.log('Length:', data.context.boundary_conditions ? data.context.boundary_conditions.length : 'N/A');
                } else {
                    console.warn('data.context is undefined or null!');
                }
                console.log('data.simulation_config:', data.simulation_config);
                if (data.simulation_config && data.simulation_config.pde_config) {
                    console.log('data.simulation_config.pde_config.boundary_conditions:', data.simulation_config.pde_config.boundary_conditions);
                }
                
                // Get boundary conditions from multiple sources (prioritize context, then pde_config)
                // Use safe access with null checks
                let boundaryConditions = null;
                if (data.context && data.context.boundary_conditions) {
                    boundaryConditions = data.context.boundary_conditions;
                    console.log('Found boundary_conditions in data.context:', boundaryConditions);
                    
                    // CRITICAL: Filter BCs to only show valid locations for current geometry
                    const geometryType = data.context.geometry_type;
                    if (geometryType && Array.isArray(boundaryConditions)) {
                        const availableBoundaries = getAvailableBoundariesForGeometry(geometryType);
                        const availableBoundariesLower = availableBoundaries.map(b => b.toLowerCase());
                        const filteredBCs = boundaryConditions.filter(bc => {
                            if (!bc || !bc.location) return false;
                            const location = bc.location.toLowerCase();
                            return availableBoundariesLower.includes(location) || 
                                   availableBoundaries.includes(bc.location);
                        });
                        if (filteredBCs.length < boundaryConditions.length) {
                            console.log(`Filtered BCs for display: ${boundaryConditions.length} -> ${filteredBCs.length} valid BCs for geometry ${geometryType}`);
                            boundaryConditions = filteredBCs;
                        }
                    }
                }
                
                // If not in context, try to get from simulation_config.pde_config
                if ((!boundaryConditions || !Array.isArray(boundaryConditions) || boundaryConditions.length === 0) && 
                    data.simulation_config && 
                    data.simulation_config.pde_config && 
                    Array.isArray(data.simulation_config.pde_config.boundary_conditions)) {
                    boundaryConditions = data.simulation_config.pde_config.boundary_conditions;
                    console.log('Found boundary_conditions in simulation_config.pde_config:', boundaryConditions);
                    // Also update context for consistency
                    if (!data.context) {
                        data.context = {};
                    }
                    if (!data.context.boundary_conditions) {
                        data.context.boundary_conditions = boundaryConditions;
                    }
                }
                
                // If still not found, check required_components
                if ((!boundaryConditions || !Array.isArray(boundaryConditions) || boundaryConditions.length === 0) && 
                    data.simulation_config && 
                    data.simulation_config.required_components &&
                    Array.isArray(data.simulation_config.required_components.boundary_conditions)) {
                    boundaryConditions = data.simulation_config.required_components.boundary_conditions;
                    console.log('Found boundary_conditions in simulation_config.required_components:', boundaryConditions);
                    // Also update context for consistency
                    if (!data.context) {
                        data.context = {};
                    }
                    if (!data.context.boundary_conditions) {
                        data.context.boundary_conditions = boundaryConditions;
                    }
                }
                
                console.log('Final boundaryConditions to display:', boundaryConditions);
                console.log('Final boundaryConditions type:', typeof boundaryConditions);
                console.log('Final boundaryConditions is array:', Array.isArray(boundaryConditions));
                console.log('Final boundaryConditions length:', boundaryConditions ? boundaryConditions.length : 'N/A');
                
                if (boundaryConditions && Array.isArray(boundaryConditions) && boundaryConditions.length > 0) {
                    console.log(`Displaying ${boundaryConditions.length} boundary condition(s)`);
                    boundaryConditions.forEach((bc, index) => {
                        // Get the actual boundary location from the mapped location
                        const boundaryLocation = (bc && bc.location) ? bc.location : ((bc && bc.mapped_location) ? bc.mapped_location : 'unknown');
                        const bcType = (bc && bc.type) ? bc.type : ((bc && bc.bc_type) ? bc.bc_type : 'free');
                        const bcValue = (bc && bc.value !== undefined && bc.value !== null) ? bc.value : '';
                        const bcSource = (bc && bc.source) ? bc.source : 'unknown';
                        
                        console.log(`  BC ${index}: location=${boundaryLocation}, type=${bcType}, value=${bcValue}, source=${bcSource}`);
                        
                        // Safely get physics_type for generateBoundaryConditionSelect
                        const physicsType = (data.context && data.context.physics_type) ? data.context.physics_type : 'solid_mechanics';
                        
                        html += `
                            <div class="context-item boundary-condition-item">
                                <div class="boundary-location">
                                    <span class="context-key">${boundaryLocation.toUpperCase()}:</span>
                                    ${bcSource === 'placeholder' ? '<span style="color: #888; font-size: 0.8em;">(placeholder)</span>' : ''}
                                </div>
                                <div class="boundary-controls">
                                    ${generateBoundaryConditionSelect(bc, index, physicsType)}
                                    <input type="text" class="config-input" 
                                           value="${Array.isArray(bcValue) ? '[' + bcValue.join(', ') + ']' : bcValue}" 
                                           placeholder="${bcType === 'traction' || bcType === 'displacement' || bcType === 'force' ? 'Value (e.g., 1000 or [1000, 2000, 0])' : 'Value (e.g., 10kN, 100°C)'}"
                                           onchange="updateBoundaryConditionValue(${index}, this.value)">
                                </div>
                            </div>
                        `;
                    });
                } else {
                    console.warn('No boundary conditions to display - boundaryConditions is empty or not an array');
                    console.warn('  boundaryConditions:', boundaryConditions);
                    console.warn('  is array:', Array.isArray(boundaryConditions));
                    console.warn('  length:', boundaryConditions ? boundaryConditions.length : 'N/A');
                    html += `
                        <div class="context-item">
                            <span class="context-key">Boundary Conditions:</span>
                            <span style="color: #888; font-size: 0.9em;">(No boundary conditions found in response)</span>
                            <input type="text" class="config-input" placeholder="e.g., fixed at one end, 100°C at top" onchange="updateConfig('boundary_conditions', this.value)">
                        </div>
                    `;
                }
                
                html += '</div>';
                
                html += '</div>';
            }
            
            // Material Properties - Dynamic and editable
            html += '<div class="material-properties">';
            html += '<div style="color: #00ff88; margin-bottom: 10px; font-weight: bold;">MATERIAL PROPERTIES:</div>';
            
            const materialType = (data.context && data.context.material_type) || 'steel';
            const physicsType = (data.context && data.context.physics_type) || 'solid_mechanics';
            const currentProperties = (data.context && data.context.material_properties) || {};
            
            // Define material property fields based on physics type
            const materialFields = getMaterialFieldsForMaterial(materialType, physicsType);
            
            materialFields.forEach(field => {
                let currentValue = currentProperties[field.name] || field.defaultValue || '';
                
                // Parse value from NLP parser format (e.g., "400 W/(m·K)" -> "400")
                if (typeof currentValue === 'string' && currentValue.includes(' ')) {
                    currentValue = currentValue.split(' ')[0];
                }
                
                html += `
                    <div class="context-item">
                        <span class="context-key">${field.label}:</span>
                        <input type="number" class="config-input" value="${currentValue}" step="${field.step || '0.01'}" placeholder="${field.placeholder}" onchange="updateConfig('material_properties.${field.name}', this.value)">
                        <span style="color: #888888; font-size: 10px;">${field.unit}</span>
                    </div>
                `;
            });
            
            html += '</div>';
            
            // Note: Mesh preview is now handled in the center panel when enough geometry info is available
            
            if (data.simulation_config && data.simulation_config.pde_config) {
                const pde = data.simulation_config.pde_config;
                
                // Mesh Details
                if (pde.mesh_parameters) {
                    html += '<div class="mesh-details">';
                    html += '<div style="color: #00ff88; margin-bottom: 10px; font-weight: bold;">MESH DETAILS:</div>';
                    
                    html += `
                        <div class="detail-item">
                            <span class="detail-key">RESOLUTION:</span>
                            <span class="detail-value">${pde.mesh_parameters.resolution || '50'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-key">ELEMENT TYPE:</span>
                            <span class="detail-value">${pde.mesh_parameters.element_type || 'Unknown'}</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-key">MESH TYPE:</span>
                            <span class="detail-value">${pde.mesh_parameters.mesh_type || 'Unknown'}</span>
                        </div>
                    `;
                    
                    html += '</div>';
                }
                
            }
            
            if (!html) {
                html = '<div class="status info">No configuration data available</div>';
            }
            
            document.getElementById('rightContent').innerHTML = html;

            // After render, populate dynamic dimensions async
            (async () => {
                const container = document.getElementById('dynamic-dimensions');
                if (!container) return;
                const geomType = (currentContext && currentContext.geometry_type) ? currentContext.geometry_type : (typeof geometryType !== 'undefined' ? geometryType : 'beam');
                const fields = await getDimensionFieldsForGeometry(geomType);
                let dimHtml = '';
                console.log('Dimensions spec fields for', geomType, fields);
                const currentDimensions = currentContext.geometry_dimensions || {};
                if (!fields || fields.length === 0) {
                    // Fallback placeholders if spec lookup failed
                    let fallback = [];
                    switch ((geomType || '').toLowerCase()) {
                        case 'line': fallback = ['length']; break;
                        case 'cylinder': fallback = ['radius','length']; break;
                        case 'cube': fallback = ['length']; break;
                        case 'box': fallback = ['length','width','height']; break;
                        case 'sphere': fallback = ['radius']; break;
                        case 'beam': fallback = ['length','width','height']; break;
                        default: fallback = ['length'];
                    }
                    dimHtml += `<div class=\"status info\">Using fallback dimension placeholders for ${geomType}</div>`;
                    fallback.forEach(name => {
                        const currentValue = currentDimensions[name] || '';
                        const label = name.charAt(0).toUpperCase() + name.slice(1);
                        dimHtml += `
                            <div class="context-item">
                                <span class="context-key">${label}:</span>
                                <input type="text" class="config-input" value="${currentValue}" placeholder="e.g., 1.0 (or 10cm)" onchange="updateConfig('geometry_dimensions.${name}', this.value)">
                            </div>
                        `;
                    });
                } else {
                    fields.forEach(field => {
                        const currentValue = currentDimensions[field.name] || '';
                        dimHtml += `
                            <div class="context-item">
                                <span class="context-key">${field.label}:</span>
                                <input type="text" class="config-input" value="${currentValue}" placeholder="${field.placeholder} (e.g., 1m or 10cm)" onchange="updateConfig('geometry_dimensions.${field.name}', this.value)">
                            </div>
                        `;
                    });
                }
                container.innerHTML = dimHtml;
            })();
        }
        
        function displayVisualization(url) {
            // This function is deprecated - use displayMeshVisualization instead
            console.log('displayVisualization is deprecated, redirecting to displayMeshVisualization');
            displayMeshVisualization(url);
        }
        
        // Global variable to store current context
        let currentContext = {};
        
        // Cache for dimensions spec
        let DIM_SPEC = null;
        async function loadDimensionsSpec() {
            if (DIM_SPEC) return DIM_SPEC;
            try {
                const res = await fetch(`${window.location.origin}/config/dimensions-spec`);
                if (!res.ok) throw new Error('Failed to load dimensions spec');
                DIM_SPEC = await res.json();
                return DIM_SPEC;
            } catch (e) {
                console.warn('Failed to fetch dimensions spec:', e);
                return null;
            }
        }

        // Helper: map geometry type to its dimension group (1D/2D/3D)
        function findDimGroupForGeometry(geometryType, spec) {
            const geom = geometryType.toLowerCase();
            const groups = spec?.geometry_dimensions || {};
            for (const group of ['1D','2D','3D']) {
                if (groups[group] && Object.prototype.hasOwnProperty.call(groups[group], geom)) return group;
            }
            return null;
        }

        // Dynamic fields from dimensions.json
        async function getDimensionFieldsForGeometry(geometryType) {
            const spec = await loadDimensionsSpec();
            if (!spec) {
                // fallback minimal
                return [{ name: 'length', label: 'Length', placeholder: 'e.g., 1.0', unit: 'm' }];
            }
            const group = findDimGroupForGeometry(geometryType, spec);
            if (!group) {
                return [{ name: 'length', label: 'Length', placeholder: 'e.g., 1.0', unit: 'm' }];
            }
            const geomDef = spec.geometry_dimensions[group][geometryType.toLowerCase()];
            const required = geomDef?.required_dimensions || [];
            const units = geomDef?.dimension_units || {};
            const pretty = {
                length: 'Length', width: 'Width', height: 'Height', thickness: 'Thickness', radius: 'Radius', diameter: 'Diameter'
            };
            return required.map(name => ({
                name,
                label: pretty[name] || name,
                placeholder: 'e.g., 1.0',
                unitOptions: units[name] || ['m','mm','cm']
            }));
        }

        // Get default dimensions for geometry type
        function getDefaultDimensionsForGeometry(geometryType) {
            const defaultDimensions = {
                'line': {length: 1.0},
                'plate': {length: 1.0, width: 1.0, thickness: 0.1},
                'membrane': {length: 1.0, width: 1.0},
                'disc': {radius: 0.5},
                'rectangle': {length: 1.0, width: 1.0},
                'cube': {length: 1.0},
                'box': {length: 1.0, width: 1.0, height: 1.0},
                'beam': {length: 1.0, width: 0.1, height: 0.1},
                'cylinder': {radius: 0.5, length: 1.0},
                'sphere': {radius: 0.5},
                'solid': {length: 1.0, width: 1.0, height: 1.0},
                'rod': {length: 1.0}
            };
            
            return defaultDimensions[geometryType] || {};
        }

        // Classify free-text geometry label (e.g., 'rod') to known types and update UI
        async function classifyAndSetGeometry(freeText) {
            const text = (freeText || '').trim();
            if (!text) return;
            try {
                const res = await fetch(`${window.location.origin}/nlp/geometry-candidates`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: text })
                });
                if (!res.ok) {
                    console.warn('Geometry classifier HTTP error', res.status);
                    return;
                }
                const data = await res.json();
                const candidates = (data && data.candidates) || [];
                if (!candidates.length) return;
                const top = candidates[0];
                // Prefer a confident mapping to avoid surprises
                if (top && top.confidence >= 0.6 && top.geometry_type) {
                    const mapped = top.geometry_type.toLowerCase();
                    if (currentContext.geometry_type !== mapped) {
                        console.log('Auto-mapped geometry to:', mapped, 'confidence:', top.confidence);
                        currentContext.geometry_type = mapped;
                        currentContext.geometry_dimensions = {}; // reset for new geometry
                        
                        // Set default dimensions for the new geometry type
                        const defaultDimensions = getDefaultDimensionsForGeometry(mapped);
                        if (defaultDimensions) {
                            currentContext.geometry_dimensions = defaultDimensions;
                            console.log(`Set default dimensions for ${mapped}:`, defaultDimensions);
                        }
                        
                        refreshRightPanel();
                    }
                }
            } catch (e) {
                console.warn('Geometry classifier failed:', e);
            }
        }
        
        // Helper function to get material property fields based on material type and physics type
        function getMaterialFieldsForMaterial(materialType, physicsType = 'solid_mechanics') {
            const thermalProperties = [
                { name: 'density', label: 'Density', unit: 'kg/m³', step: '1' },
                { name: 'thermal_conductivity', label: 'Thermal Conductivity', unit: 'W/(m·K)', step: '1' },
                { name: 'specific_heat', label: 'Specific Heat', unit: 'J/(kg·K)', step: '1' },
                { name: 'thermal_expansion', label: 'Thermal Expansion', unit: '/K', step: '0.00001' }
            ];
            
            const structuralProperties = [
                { name: 'density', label: 'Density', unit: 'kg/m³', step: '1' },
                { name: 'youngs_modulus', label: 'Young\'s Modulus', unit: 'Pa', step: '1000000' },
                { name: 'poisson_ratio', label: 'Poisson Ratio', unit: '', step: '0.01' }
            ];
            
            // For heat transfer, prioritize thermal properties
            if (physicsType === 'heat_transfer') {
                switch(materialType.toLowerCase()) {
                    case 'steel':
                        return thermalProperties.map(prop => ({
                            ...prop,
                            defaultValue: prop.name === 'density' ? '7850' :
                                        prop.name === 'thermal_conductivity' ? '50' :
                                        prop.name === 'specific_heat' ? '460' :
                                        prop.name === 'thermal_expansion' ? '0.000012' : ''
                        }));
                    case 'aluminum':
                        return thermalProperties.map(prop => ({
                            ...prop,
                            defaultValue: prop.name === 'density' ? '2700' :
                                        prop.name === 'thermal_conductivity' ? '205' :
                                        prop.name === 'specific_heat' ? '900' :
                                        prop.name === 'thermal_expansion' ? '0.000023' : ''
                        }));
                    case 'concrete':
                        return thermalProperties.map(prop => ({
                            ...prop,
                            defaultValue: prop.name === 'density' ? '2300' :
                                        prop.name === 'thermal_conductivity' ? '1.7' :
                                        prop.name === 'specific_heat' ? '880' :
                                        prop.name === 'thermal_expansion' ? '0.000010' : ''
                        }));
                    case 'wood':
                        return thermalProperties.map(prop => ({
                            ...prop,
                            defaultValue: prop.name === 'density' ? '600' :
                                        prop.name === 'thermal_conductivity' ? '0.12' :
                                        prop.name === 'specific_heat' ? '1700' :
                                        prop.name === 'thermal_expansion' ? '0.000005' : ''
                        }));
                    case 'copper':
                        return thermalProperties.map(prop => ({
                            ...prop,
                            defaultValue: prop.name === 'density' ? '8900' :
                                        prop.name === 'thermal_conductivity' ? '400' :
                                        prop.name === 'specific_heat' ? '385' :
                                        prop.name === 'thermal_expansion' ? '0.000017' : ''
                        }));
                    default:
                        return thermalProperties;
                }
            }
            
            // For structural analysis, use structural properties
            switch(materialType.toLowerCase()) {
                case 'steel':
                    return [
                        ...structuralProperties,
                        { name: 'yield_strength', label: 'Yield Strength', unit: 'Pa', step: '1000000', defaultValue: '250000000' },
                        { name: 'thermal_conductivity', label: 'Thermal Conductivity', unit: 'W/(m·K)', step: '1', defaultValue: '50' },
                        { name: 'specific_heat', label: 'Specific Heat', unit: 'J/(kg·K)', step: '1', defaultValue: '460' }
                    ];
                case 'aluminum':
                    return [
                        ...structuralProperties,
                        { name: 'yield_strength', label: 'Yield Strength', unit: 'Pa', step: '1000000', defaultValue: '95000000' },
                        { name: 'thermal_conductivity', label: 'Thermal Conductivity', unit: 'W/(m·K)', step: '1', defaultValue: '205' },
                        { name: 'specific_heat', label: 'Specific Heat', unit: 'J/(kg·K)', step: '1', defaultValue: '900' }
                    ];
                case 'concrete':
                    return [
                        ...structuralProperties,
                        { name: 'compressive_strength', label: 'Compressive Strength', unit: 'Pa', step: '1000000', defaultValue: '30000000' },
                        { name: 'thermal_conductivity', label: 'Thermal Conductivity', unit: 'W/(m·K)', step: '1', defaultValue: '1.7' },
                        { name: 'specific_heat', label: 'Specific Heat', unit: 'J/(kg·K)', step: '1', defaultValue: '880' }
                    ];
                case 'wood':
                    return [
                        ...structuralProperties,
                        { name: 'compressive_strength', label: 'Compressive Strength', unit: 'Pa', step: '1000000', defaultValue: '40000000' },
                        { name: 'thermal_conductivity', label: 'Thermal Conductivity', unit: 'W/(m·K)', step: '1', defaultValue: '0.12' },
                        { name: 'specific_heat', label: 'Specific Heat', unit: 'J/(kg·K)', step: '1', defaultValue: '1700' }
                    ];
                default:
                    return structuralProperties;
            }
        }
        
        function updateConfig(field, value) {
            console.log(`Updating config: ${field} = ${value}`);
            
            // Parse the input value intelligently
            const parsedValue = parseConfigInput(field, value);
            
            // CRITICAL: Ensure window.currentContext exists and is in sync
            if (!window.currentContext) {
                window.currentContext = currentContext || {};
            }
            
            // Mark this field as UI-modified (takes precedence over parsed values)
            // Store in a separate tracking object for context merging
            if (!window.uiModifiedFields) {
                window.uiModifiedFields = new Set();
            }
            window.uiModifiedFields.add(field);
            
            // Update the current context
            if (field.includes('.')) {
                const parts = field.split('.');
                let obj = currentContext;
                let windowObj = window.currentContext;
                
                // Ensure both contexts have the nested structure
                for (let i = 0; i < parts.length - 1; i++) {
                    if (!obj[parts[i]]) obj[parts[i]] = {};
                    if (!windowObj[parts[i]]) windowObj[parts[i]] = {};
                    obj = obj[parts[i]];
                    windowObj = windowObj[parts[i]];
                }
                obj[parts[parts.length - 1]] = parsedValue;
                windowObj[parts[parts.length - 1]] = parsedValue;
                
                console.log(`Updated nested field ${field} = ${parsedValue} in both currentContext and window.currentContext`);
            } else {
                currentContext[field] = parsedValue;
                window.currentContext[field] = parsedValue;
                console.log(`Updated field ${field} = ${parsedValue} in both currentContext and window.currentContext`);
            }
            
            // Show a status message
            showStatus('info', `Updated ${field}: ${parsedValue}`);
            
            // TOP LEVEL CHANGES - Trigger validation and affect pde_config
            if (field === 'physics_type' || field === 'geometry_type' || field === 'material_type') {
                console.log(`TOP LEVEL CHANGE: ${field} changed to ${parsedValue}`);
                
                // Clear dependent fields when top level changes
                if (field === 'physics_type') {
                    // Physics type change affects boundary condition fields
                    currentContext.boundary_conditions = [];
                    console.log('Cleared boundary conditions due to physics type change');
                } else if (field === 'geometry_type') {
                    // Geometry type change affects dimensions and boundary locations
                    // Set default dimensions for the new geometry type BEFORE clearing
                    const validGeometryTypes = ['line', 'rod', 'bar', 'plate', 'membrane', 'disc', 'rectangle', 'square', 'cube', 'box', 'beam', 'cylinder', 'sphere'];
                    if (validGeometryTypes.includes(parsedValue)) {
                        // Set default dimensions immediately for the new geometry type
                        const defaultDimensions = getDefaultDimensionsForGeometry(parsedValue);
                        if (defaultDimensions && Object.keys(defaultDimensions).length > 0) {
                            // Ensure all values are numbers, not strings
                            const normalizedDimensions = {};
                            for (const [key, value] of Object.entries(defaultDimensions)) {
                                if (typeof value === 'string') {
                                    const parsed = parseFloat(value);
                                    normalizedDimensions[key] = isNaN(parsed) ? value : parsed;
                                } else {
                                    normalizedDimensions[key] = value;
                                }
                            }
                            currentContext.geometry_dimensions = normalizedDimensions;
                            console.log(`Set default dimensions for ${parsedValue}:`, normalizedDimensions);
                        } else {
                            // Clear dimensions if no defaults available
                            currentContext.geometry_dimensions = {};
                            console.warn(`No default dimensions found for geometry type: ${parsedValue}`);
                        }
                    } else {
                        // Clear dimensions if geometry type is invalid
                        currentContext.geometry_dimensions = {};
                        console.warn(`Invalid geometry type: ${parsedValue}`);
                    }
                    // Clear boundary conditions - they will be set by parseTopLevelChange
                    currentContext.boundary_conditions = [];
                    console.log('Updated dimensions and cleared boundary conditions due to geometry type change');
            } else if (field === 'material_type') {
                    // Material type change affects material properties
                currentContext.material_properties = {};
                    console.log('Cleared material properties due to material type change');
                }
                
                // Trigger validation for top level changes
                setTimeout(() => {
                    parseTopLevelChange(field, parsedValue);
                }, 100);
                
                // Refresh right panel to show updated fields
                setTimeout(() => {
                    refreshRightPanel();
                }, 200);
                
                // For geometry_type changes, also trigger immediate mesh generation after a delay
                // to ensure dimensions are set and panel is refreshed
                if (field === 'geometry_type') {
                    // First, ensure dimensions are set (they should be set above)
                    // Then trigger mesh generation after parseTopLevelChange completes
                    setTimeout(() => {
                        // Re-check dimensions after parseTopLevelChange has run
                        const hasValidDimensions = currentContext.geometry_dimensions && 
                            Object.keys(currentContext.geometry_dimensions).length > 0 &&
                            Object.values(currentContext.geometry_dimensions).some(val => {
                                if (val === null || val === undefined || val === '' || val === '0') return false;
                                const numVal = typeof val === 'string' ? parseFloat(val.trim()) : val;
                                return !isNaN(numVal) && numVal > 0;
                            });
                        
                        if (hasValidDimensions && currentContext.geometry_type === parsedValue) {
                            console.log(`Triggering mesh generation from updateConfig for geometry type: ${currentContext.geometry_type} with dimensions:`, currentContext.geometry_dimensions);
                            generateMeshPreviewInCenter();
                        } else {
                            console.warn(`Cannot generate mesh: geometry_type=${currentContext.geometry_type}, hasValidDimensions=${hasValidDimensions}, dimensions=`, currentContext.geometry_dimensions);
                        }
                    }, 600); // Delay to ensure parseTopLevelChange and refreshRightPanel have completed
                }
            }
            
            // NEXT LEVEL CHANGES - Only affect pde_config, no AI parsing
            else if (field.startsWith('geometry_dimensions.') || 
                     field.startsWith('material_properties.') || 
                     field.startsWith('boundary_conditions.')) {
                console.log(`NEXT LEVEL CHANGE: ${field} changed to ${parsedValue}`);
                
                // CRITICAL: Update window.currentContext for nested fields
                if (!window.currentContext) {
                    window.currentContext = {};
                }
                const parts = field.split('.');
                if (parts.length === 2) {
                    const [parentField, childField] = parts;
                    if (!window.currentContext[parentField]) {
                        window.currentContext[parentField] = {};
                    }
                    if (parentField === 'geometry_dimensions' || parentField === 'material_properties') {
                        window.currentContext[parentField][childField] = parsedValue;
                    }
                }
                
                // Update pde_config for next level changes
                setTimeout(() => {
                    updatePdeConfigFromContext();
                }, 100);
                
                // Handle mesh preview for dimension changes
                if (field.startsWith('geometry_dimensions.')) {
                    // Check if we have enough dimensions for mesh preview
                    const hasValidDimensions = currentContext.geometry_dimensions && 
                        Object.keys(currentContext.geometry_dimensions).length > 0 &&
                        Object.values(currentContext.geometry_dimensions).some(val => val && val !== '');
                    
                    if (currentContext.geometry_type && hasValidDimensions) {
                        setTimeout(() => {
                            generateMeshPreviewInCenter();
                        }, 200);
                    }
                    // Refresh right panel to show updated dimension values
                    setTimeout(() => {
                        refreshRightPanel();
                    }, 50);
                }
                
                // Refresh right panel for material property changes
                if (field.startsWith('material_properties.')) {
                    setTimeout(() => {
                        refreshRightPanel();
                    }, 100);
                }
            }
            
            // For geometry_type changes, mesh generation is handled in parseTopLevelChange
            // For dimension changes, trigger mesh generation immediately
            if (field.startsWith('geometry_dimensions.')) {
                console.log('Dimension changed:', field, 'New value:', parsedValue);
                console.log('Updated dimensions:', currentContext.geometry_dimensions);
                
                // Check if we have valid dimensions for mesh generation
                const hasValidDimensions = currentContext.geometry_dimensions && 
                    Object.keys(currentContext.geometry_dimensions).length > 0 &&
                    Object.values(currentContext.geometry_dimensions).some(val => val && val !== '' && val !== null && val !== undefined && parseFloat(val) > 0);
                
                // Immediately trigger mesh update for dimension changes
                if (currentContext.geometry_type && hasValidDimensions) {
                    console.log('Triggering immediate mesh preview update for dimension change');
                    setTimeout(() => {
                        generateMeshPreviewInCenter();
                    }, 300); // Shorter delay for dimension changes
                }
            }
            // Note: geometry_type changes trigger mesh generation in parseTopLevelChange
            
            // CRITICAL: Update button visibility after config update
            // This ensures the button reflects the current context state
            // Use a delay to ensure all async updates are complete
            setTimeout(() => {
                updateButtonVisibility();
            }, 300);
        }
        
        // Get default dimensions for a geometry type
        function getDefaultDimensionsForGeometry(geometryType) {
            const defaultDimensions = {
                'line': { length: 1.0 },
                'rod': { length: 1.0 },
                'bar': { length: 1.0 },
                'plate': { length: 1.0, width: 0.8, thickness: 0.02 },
                'membrane': { length: 1.0, width: 0.8 },
                'disc': { radius: 0.5 },
                'rectangle': { length: 1.0, width: 0.8 },
                'square': { length: 1.0 },
                'cube': { length: 1.0, width: 1.0, height: 1.0 },  // 1x1x1 cube (all sides equal)
                'box': { length: 1.0, width: 2.0, height: 1.0 },  // 1x2x1 cuboid
                'beam': { length: 1.0, width: 0.1, height: 0.1 },
                'cylinder': { radius: 0.5, length: 1.0 },  // 1m length, 0.5m radius
                'sphere': { radius: 0.5 }
            };
            
            return defaultDimensions[geometryType] || {};
        }
        
        // Get available boundary locations for a geometry type
        function getAvailableBoundariesForGeometry(geometryType) {
            const boundaryMapping = {
                'line': ['left', 'right'],
                'rod': ['left', 'right'],
                'bar': ['left', 'right'],
                'plate': ['left', 'right', 'top', 'bottom'],
                'membrane': ['left', 'right', 'top', 'bottom'],
                'disc': ['circumference', 'center'],
                'rectangle': ['left', 'right', 'top', 'bottom'],
                'square': ['left', 'right', 'top', 'bottom'],
                'cube': ['left', 'right', 'top', 'bottom', 'front', 'back'],
                'box': ['left', 'right', 'top', 'bottom', 'front', 'back'],
                'beam': ['left', 'right', 'top', 'bottom', 'front', 'back'],
                'cylinder': ['top', 'bottom', 'curved surface'],
                'sphere': ['surface', 'center']
            };
            
            return boundaryMapping[geometryType] || [];
        }
        
        // Parse top level changes with validation
        async function parseTopLevelChange(field, value) {
            try {
                console.log(`=== VALIDATION FOR TOP LEVEL CHANGE ===`);
                console.log(`Field: ${field}, Value: ${value}`);
                console.log(`Current context:`, window.currentContext);
                
                // For now, use validation against pre-set values instead of AI parsing
                // This ensures we use the correct geometry types, boundary locations, fields, and material properties
                
                if (field === 'geometry_type') {
                    // Validate geometry type and ensure default dimensions are set
                    const validGeometryTypes = ['line', 'rod', 'bar', 'plate', 'membrane', 'disc', 'rectangle', 'square', 'cube', 'box', 'beam', 'cylinder', 'sphere'];
                    if (validGeometryTypes.includes(value)) {
                        // Ensure default dimensions are set (may have been set in updateConfig)
                        // Check if dimensions are missing or incomplete for the new geometry type
                        const requiredDims = getRequiredDimensionsForGeometry(value);
                        const currentDims = currentContext.geometry_dimensions || {};
                        const missingDims = requiredDims.filter(dim => !currentDims[dim] || currentDims[dim] === '' || currentDims[dim] === null || currentDims[dim] === undefined);
                        
                        if (missingDims.length > 0 || Object.keys(currentDims).length === 0) {
                            // Get default dimensions and fill in missing ones
                            const defaultDimensions = getDefaultDimensionsForGeometry(value);
                            if (defaultDimensions && Object.keys(defaultDimensions).length > 0) {
                                // Normalize default dimensions to ensure they're numbers
                                const normalizedDefaults = {};
                                for (const [key, val] of Object.entries(defaultDimensions)) {
                                    normalizedDefaults[key] = typeof val === 'string' ? parseFloat(val) || val : val;
                                }
                                
                                // Merge defaults with existing dimensions, prioritizing defaults for missing dimensions
                                const mergedDims = { ...normalizedDefaults };
                                // Preserve existing valid dimensions
                                for (const [key, val] of Object.entries(currentDims)) {
                                    if (val !== null && val !== undefined && val !== '') {
                                        mergedDims[key] = typeof val === 'string' ? parseFloat(val) || val : val;
                                    }
                                }
                                
                                // Ensure all required dimensions are present with default values
                                requiredDims.forEach(dim => {
                                    if (!mergedDims[dim] || mergedDims[dim] === '' || mergedDims[dim] === null || mergedDims[dim] === undefined) {
                                        mergedDims[dim] = normalizedDefaults[dim];
                                    }
                                });
                                
                                currentContext.geometry_dimensions = mergedDims;
                                console.log(`Updated dimensions for ${value}:`, currentContext.geometry_dimensions);
                            } else {
                                console.warn(`No default dimensions available for geometry type: ${value}`);
                            }
                        }
                        
                        // Always set default boundary conditions based on geometry type and physics type
                        // This ensures boundary conditions match the new geometry type
                        const availableBoundaries = getAvailableBoundariesForGeometry(value);
                        const physicsType = currentContext.physics_type || 'heat_transfer';
                        
                        // Helper function to select appropriate boundary locations for BCs
                        function selectBoundaryLocations(boundaries, geometryType) {
                            // For special geometries, prefer certain boundaries
                            if (geometryType === 'cylinder') {
                                // Prefer 'top' and 'bottom' over 'curved surface'
                                const topBottom = boundaries.filter(b => b === 'top' || b === 'bottom');
                                if (topBottom.length >= 2) return topBottom;
                                if (topBottom.length === 1 && boundaries.includes('curved surface')) {
                                    return [topBottom[0], 'curved surface'];
                                }
                            } else if (geometryType === 'sphere') {
                                // Return both 'surface' and 'center' if available
                                const sphereBoundaries = [];
                                if (boundaries.includes('surface')) sphereBoundaries.push('surface');
                                if (boundaries.includes('center')) sphereBoundaries.push('center');
                                if (sphereBoundaries.length > 0) return sphereBoundaries;
                            } else if (geometryType === 'disc') {
                                // Prefer 'circumference' over 'center'
                                if (boundaries.includes('circumference')) {
                                    if (boundaries.includes('center')) {
                                        return ['circumference', 'center'];
                                    }
                                    return ['circumference'];
                                }
                                if (boundaries.includes('center')) return ['center'];
                            }
                            // Default: use first and last, or first if only one
                            if (boundaries.length >= 2) {
                                return [boundaries[0], boundaries[boundaries.length - 1]];
                            }
                            return boundaries.length > 0 ? [boundaries[0]] : [];
                        }
                        
                        const selectedBoundaries = selectBoundaryLocations(availableBoundaries, value);
                        
                        if (selectedBoundaries.length > 0) {
                            // Set boundary conditions based on physics type
                            if (physicsType === 'heat_transfer') {
                                // Heat transfer: use temperature boundary conditions
                                if (selectedBoundaries.length >= 2) {
                                    // For geometries with multiple boundaries, set temperature on selected boundaries
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[0],
                                            value: 100,
                                            confidence: 0.9
                                        },
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[1],
                                            value: 10,
                                            confidence: 0.9
                                        }
                                    ];
                                } else if (selectedBoundaries.length === 1) {
                                    // For geometries with single boundary (like sphere surface)
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[0],
                                            value: 100,
                                            confidence: 0.9
                                        }
                                    ];
                                }
                            } else if (physicsType === 'solid_mechanics') {
                                // Solid mechanics: use fixed/displacement boundary conditions
                                if (selectedBoundaries.length >= 2) {
                                    // For geometries with multiple boundaries, fix first and apply load on last
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'fixed',
                                            location: selectedBoundaries[0],
                                            value: [0.0, 0.0, 0.0],
                                            confidence: 0.9
                                        },
                                        {
                                            type: 'force',
                                            location: selectedBoundaries[1],
                                            value: [0.0, -1000.0, 0.0],
                                            confidence: 0.9
                                        }
                                    ];
                                } else if (selectedBoundaries.length === 1) {
                                    // For geometries with single boundary
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'fixed',
                                            location: selectedBoundaries[0],
                                            value: [0.0, 0.0, 0.0],
                                            confidence: 0.9
                                        }
                                    ];
                                }
                            } else {
                                // Default: use heat transfer boundary conditions
                                if (selectedBoundaries.length >= 2) {
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[0],
                                            value: 100,
                                            confidence: 0.9
                                        },
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[1],
                                            value: 10,
                                            confidence: 0.9
                                        }
                                    ];
                                } else if (selectedBoundaries.length === 1) {
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[0],
                                            value: 100,
                                            confidence: 0.9
                                        }
                                    ];
                                }
                            }
                            
                            console.log(`Set default boundary conditions for ${value} (physics: ${physicsType}):`, currentContext.boundary_conditions);
                            // Update window.currentContext to ensure it's in sync
                            if (window.currentContext) {
                                window.currentContext.boundary_conditions = currentContext.boundary_conditions;
                            }
                        } else {
                            // No boundaries available for this geometry type
                            currentContext.boundary_conditions = [];
                            console.warn(`No boundary locations available for geometry type: ${value}`);
                            // Update window.currentContext to ensure it's in sync
                            if (window.currentContext) {
                                window.currentContext.boundary_conditions = [];
                            }
                        }
                    }
                } else if (field === 'physics_type') {
                    // Validate physics type and update boundary conditions to match physics type
                    const validPhysicsTypes = ['heat_transfer', 'solid_mechanics'];
                    if (validPhysicsTypes.includes(value)) {
                        // Get current geometry type to set appropriate boundary conditions
                        const geometryType = currentContext.geometry_type;
                        const availableBoundaries = geometryType ? getAvailableBoundariesForGeometry(geometryType) : [];
                        
                        // Helper function to select appropriate boundary locations for BCs (same as above)
                        function selectBoundaryLocationsForPhysics(boundaries, geomType) {
                            // For special geometries, prefer certain boundaries
                            if (geomType === 'cylinder') {
                                // Prefer 'top' and 'bottom' over 'curved surface'
                                const topBottom = boundaries.filter(b => b === 'top' || b === 'bottom');
                                if (topBottom.length >= 2) return topBottom;
                                if (topBottom.length === 1 && boundaries.includes('curved surface')) {
                                    return [topBottom[0], 'curved surface'];
                                }
                            } else if (geomType === 'sphere') {
                                // Return both 'surface' and 'center' if available
                                const sphereBoundaries = [];
                                if (boundaries.includes('surface')) sphereBoundaries.push('surface');
                                if (boundaries.includes('center')) sphereBoundaries.push('center');
                                if (sphereBoundaries.length > 0) return sphereBoundaries;
                            } else if (geomType === 'disc') {
                                // Prefer 'circumference' over 'center'
                                if (boundaries.includes('circumference')) {
                                    if (boundaries.includes('center')) {
                                        return ['circumference', 'center'];
                                    }
                                    return ['circumference'];
                                }
                                if (boundaries.includes('center')) return ['center'];
                            }
                            // Default: use first and last, or first if only one
                            if (boundaries.length >= 2) {
                                return [boundaries[0], boundaries[boundaries.length - 1]];
                            }
                            return boundaries.length > 0 ? [boundaries[0]] : [];
                        }
                        
                        const selectedBoundaries = selectBoundaryLocationsForPhysics(availableBoundaries, geometryType);
                        
                        if (selectedBoundaries.length > 0) {
                            // Reset boundary conditions based on new physics type and current geometry
                            if (value === 'heat_transfer') {
                                // Heat transfer: use temperature boundary conditions
                                if (selectedBoundaries.length >= 2) {
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[0],
                                            value: 100,
                                            confidence: 0.9
                                        },
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[1],
                                            value: 10,
                                            confidence: 0.9
                                        }
                                    ];
                                } else if (selectedBoundaries.length === 1) {
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'temperature',
                                            location: selectedBoundaries[0],
                                            value: 100,
                                            confidence: 0.9
                                        }
                                    ];
                                }
                            } else if (value === 'solid_mechanics') {
                                // Solid mechanics: use fixed/displacement boundary conditions
                                if (selectedBoundaries.length >= 2) {
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'fixed',
                                            location: selectedBoundaries[0],
                                            value: [0.0, 0.0, 0.0],
                                            confidence: 0.9
                                        },
                                        {
                                            type: 'force',
                                            location: selectedBoundaries[1],
                                            value: [0.0, -1000.0, 0.0],
                                            confidence: 0.9
                                        }
                                    ];
                                } else if (selectedBoundaries.length === 1) {
                                    currentContext.boundary_conditions = [
                                        {
                                            type: 'fixed',
                                            location: selectedBoundaries[0],
                                            value: [0.0, 0.0, 0.0],
                                            confidence: 0.9
                                        }
                                    ];
                                }
                            }
                            console.log(`Updated boundary conditions for physics type ${value} (geometry: ${geometryType}):`, currentContext.boundary_conditions);
                            // CRITICAL: Update window.currentContext to ensure it's in sync
                            if (!window.currentContext) {
                                window.currentContext = {};
                            }
                            window.currentContext.boundary_conditions = currentContext.boundary_conditions;
                            console.log(`Synced boundary_conditions to window.currentContext: ${currentContext.boundary_conditions.length} BC(s)`);
                        } else {
                            // No geometry type set yet, just clear boundary conditions
                            currentContext.boundary_conditions = [];
                            console.log(`Cleared boundary conditions (no geometry type set)`);
                            // CRITICAL: Update window.currentContext to ensure it's in sync
                            if (!window.currentContext) {
                                window.currentContext = {};
                            }
                            window.currentContext.boundary_conditions = [];
                        }
                    }
                } else if (field === 'material_type') {
                    // Validate material type and set default material properties
                    const validMaterialTypes = ['steel', 'aluminum', 'copper', 'concrete', 'wood', 'titanium', 'brass', 'stainless_steel', 'cast_iron', 'glass'];
                    if (validMaterialTypes.includes(value)) {
                        // Set default material properties based on material type
                        const defaultProperties = getDefaultMaterialProperties(value, currentContext.physics_type || 'solid_mechanics');
                        if (defaultProperties) {
                            currentContext.material_properties = defaultProperties;
                            // CRITICAL: Update window.currentContext to ensure it's in sync
                            if (!window.currentContext) {
                                window.currentContext = {};
                            }
                            window.currentContext.material_properties = defaultProperties;
                            console.log(`Set default material properties for ${value}:`, defaultProperties);
                        }
                    }
                }
                
                // CRITICAL: Sync all context changes to window.currentContext
                if (!window.currentContext) {
                    window.currentContext = {};
                }
                // Sync all context fields to window.currentContext
                if (field === 'physics_type') {
                    window.currentContext.physics_type = value;
                    window.currentContext.boundary_conditions = currentContext.boundary_conditions || [];
                } else if (field === 'geometry_type') {
                    window.currentContext.geometry_type = value;
                    window.currentContext.geometry_dimensions = currentContext.geometry_dimensions || {};
                    window.currentContext.boundary_conditions = currentContext.boundary_conditions || [];
                } else if (field === 'material_type') {
                    window.currentContext.material_type = value;
                    window.currentContext.material_properties = currentContext.material_properties || {};
                }
                console.log(`Synced ${field} change to window.currentContext`);
                
                // Update pde_config after validation
                setTimeout(() => {
                    updatePdeConfigFromContext();
                }, 100);
                
                // For geometry type changes, ensure mesh is generated after dimensions are set
                if (field === 'geometry_type') {
                    // Wait a bit longer to ensure dimensions are fully set and normalized
                    setTimeout(() => {
                        const hasValidDimensions = currentContext.geometry_dimensions && 
                            Object.keys(currentContext.geometry_dimensions).length > 0 &&
                            Object.values(currentContext.geometry_dimensions).some(val => {
                                if (val === null || val === undefined || val === '' || val === '0') return false;
                                const numVal = typeof val === 'string' ? parseFloat(val.trim()) : val;
                                return !isNaN(numVal) && numVal > 0;
                            });
                        
                        if (hasValidDimensions && currentContext.geometry_type === value) {
                            console.log(`Geometry type changed to ${value}, triggering mesh generation from parseTopLevelChange with dimensions:`, currentContext.geometry_dimensions);
                            generateMeshPreviewInCenter();
                        } else {
                            console.warn(`Geometry type changed to ${value}, but no valid dimensions found. geometry_type=${currentContext.geometry_type}, dimensions=`, currentContext.geometry_dimensions);
                        }
                    }, 500); // Delay to ensure all updates are complete and dimensions are normalized
                }
                
                // CRITICAL: Update button visibility after top-level change validation
                setTimeout(() => {
                    updateButtonVisibility();
                }, 300);
                
                showStatus('success', `Validated ${field} change successfully`);
                
            } catch (error) {
                console.error('Error in top level change validation:', error);
                showStatus('error', `Validation error: ${error.message}`);
            }
        }
        
        // Get default material properties for a material type and physics type
        function getDefaultMaterialProperties(materialType, physicsType) {
            const materialProperties = {
                'steel': {
                    'heat_transfer': { density: 7850, thermal_conductivity: 50, specific_heat: 460 },
                    'solid_mechanics': { density: 7850, youngs_modulus: 200000000000, poisson_ratio: 0.3 }
                },
                'aluminum': {
                    'heat_transfer': { density: 2700, thermal_conductivity: 205, specific_heat: 900 },
                    'solid_mechanics': { density: 2700, youngs_modulus: 70000000000, poisson_ratio: 0.33 }
                },
                'copper': {
                    'heat_transfer': { density: 8960, thermal_conductivity: 400, specific_heat: 385 },
                    'solid_mechanics': { density: 8960, youngs_modulus: 110000000000, poisson_ratio: 0.34 }
                },
                'concrete': {
                    'heat_transfer': { density: 2300, thermal_conductivity: 1.7, specific_heat: 880 },
                    'solid_mechanics': { density: 2300, youngs_modulus: 30000000000, poisson_ratio: 0.2 }
                },
                'wood': {
                    'heat_transfer': { density: 600, thermal_conductivity: 0.12, specific_heat: 1700 },
                    'solid_mechanics': { density: 600, youngs_modulus: 12000000000, poisson_ratio: 0.4 }
                }
            };
            
            return materialProperties[materialType]?.[physicsType] || {};
        }
        
        function refreshRightPanel() {
            // Only refresh if there's actual context data
            if (!window.currentContext || Object.keys(window.currentContext).length === 0) {
                // Show placeholder if no context
                const rightContent = document.getElementById('rightContent');
                if (rightContent) {
                    rightContent.innerHTML = `
                        <div class="status info">
                            Material properties, geometry details, and mesh parameters will be displayed here...
                        </div>
                    `;
                }
                return;
            }
            
            // Create a mock data object with current context
            const mockData = {
                success: true,
                context: window.currentContext
            };
            displayRightPanel(mockData);
            
            // CRITICAL: Update button visibility after refreshing right panel
            // This ensures the button reflects the current context state
            setTimeout(() => {
                updateButtonVisibility();
            }, 100);
        }

        // Initialize panels on load - show placeholders if no context
        window.addEventListener('load', () => {
            // Initialize left panel with placeholder if no prompt
            const leftContent = document.getElementById('leftContent');
            if (leftContent && (!window.currentContext || !window.currentContext.prompt)) {
                leftContent.innerHTML = `
                    <div class="status info">
                        Submit a physics simulation prompt to see equations and controls here...
                    </div>
                `;
            }
            
            // Only refresh right panel if there's actual context data
            if (window.currentContext && Object.keys(window.currentContext).length > 0) {
                refreshRightPanel();
            } else {
                // Show placeholder in right panel
                const rightContent = document.getElementById('rightContent');
                if (rightContent) {
                    rightContent.innerHTML = `
                        <div class="status info">
                            Material properties, geometry details, and mesh parameters will be displayed here...
                        </div>
                    `;
                }
            }
        });
        
        function parseConfigInput(field, value) {
            if (!value || value.trim() === '') return value;
            
            const trimmedValue = value.trim();
            
            // Handle dimension inputs - extract numbers and units
            if (field.includes('dimensions') || field.includes('length') || field.includes('radius') || field.includes('width') || field.includes('height') || field.includes('diameter')) {
                // Extract number from input like "2m", "1.5 meters", "50cm", "60cm diameter", etc.
                // First try to match number followed by unit
                let numberMatch = trimmedValue.match(/(\d+(?:\.\d+)?)\s*(?:m|meter|meters|cm|mm|inch|inches|km)\b/i);
                if (!numberMatch) {
                    // If no unit found after number, try to find unit anywhere in the string
                    numberMatch = trimmedValue.match(/(\d+(?:\.\d+)?)/);
                }
                if (numberMatch) {
                    let num = parseFloat(numberMatch[1]);
                    const lowerValue = trimmedValue.toLowerCase();
                    
                    // Convert units if needed - check for specific unit patterns
                    if (lowerValue.includes('cm')) num = num / 100;           // cm to m
                    if (lowerValue.includes('mm')) num = num / 1000;           // mm to m
                    if (lowerValue.includes('inch')) num = num * 0.0254;       // inch to m
                    if (lowerValue.includes('km')) num = num * 1000;           // km to m
                    
                    console.log(`Parsed dimension: ${trimmedValue} -> ${num} m`);
                    return num.toString();
                }
                return trimmedValue;
            }
            
            // Handle material inputs
            if (field.includes('material')) {
                // Standardize common material names
                const material = trimmedValue.toLowerCase();
                if (material.includes('steel')) return 'steel';
                if (material.includes('aluminum') || material.includes('aluminium')) return 'aluminum';
                if (material.includes('concrete')) return 'concrete';
                if (material.includes('wood')) return 'wood';
                if (material.includes('plastic')) return 'plastic';
                return trimmedValue;
            }
            
            // Handle geometry type inputs
            if (field.includes('geometry_type')) {
                const geometry = trimmedValue.toLowerCase();
                if (geometry.includes('beam')) return 'beam';
                if (geometry.includes('plate')) return 'plate';
                if (geometry.includes('shell')) return 'shell';
                if (geometry.includes('solid')) return 'solid';
                if (geometry.includes('cylinder')) return 'cylinder';
                if (geometry.includes('sphere')) return 'sphere';
                return trimmedValue;
            }
            
            // Handle boundary condition inputs
            if (field.includes('boundary_conditions')) {
                // Parse common boundary condition patterns
                const bc = trimmedValue.toLowerCase();
                if (bc.includes('fixed') || bc.includes('clamped')) return 'fixed';
                if (bc.includes('free') || bc.includes('unconstrained')) return 'free';
                if (bc.includes('simply supported') || bc.includes('pinned')) return 'simply_supported';
                if (bc.includes('temperature') || bc.includes('°c') || bc.includes('°f')) return trimmedValue;
                if (bc.includes('load') || bc.includes('force') || bc.includes('n')) return trimmedValue;
                return trimmedValue;
            }
            
            // Handle temperature inputs
            if (field.includes('temperature')) {
                const tempMatch = trimmedValue.match(/(\d+(?:\.\d+)?)\s*(?:°c|°f|celsius|fahrenheit)?/i);
                if (tempMatch) {
                    let temp = parseFloat(tempMatch[1]);
                    // Convert to Celsius if Fahrenheit
                    if (trimmedValue.toLowerCase().includes('f') || trimmedValue.toLowerCase().includes('fahrenheit')) {
                        temp = (temp - 32) * 5/9;
                    }
                    return temp.toString();
                }
                return trimmedValue;
            }
            
            // Handle force/load inputs
            if (field.includes('load') || field.includes('force') || field.includes('value')) {
                // Enhanced regex to match various force units
                const forceMatch = trimmedValue.match(/(\d+(?:\.\d+)?)\s*(?:n|newton|newtons|kn|mn|gn|lb|lbf|kgf|ton|tons)?/i);
                if (forceMatch) {
                    let force = parseFloat(forceMatch[1]);
                    const unit = trimmedValue.toLowerCase();
                    
                    // Convert units to Newtons
                    if (unit.includes('kn')) force = force * 1000;           // kN to N
                    if (unit.includes('mn')) force = force * 1000000;        // MN to N
                    if (unit.includes('gn')) force = force * 1000000000;      // GN to N
                    if (unit.includes('lb') || unit.includes('lbf')) force = force * 4.448; // lbf to N
                    if (unit.includes('kgf')) force = force * 9.807;         // kgf to N
                    if (unit.includes('ton')) force = force * 9807;          // ton-force to N
                    
                    console.log(`Parsed force: ${trimmedValue} -> ${force} N`);
                    return force.toString();
                }
                return trimmedValue;
            }
            
            // Default: return the trimmed value
            return trimmedValue;
        }
        
        function generateMeshPreviewInCenter() {
            const centerContent = document.getElementById('centerContent');
            
            console.log('=== GENERATING MESH PREVIEW ===');
            console.log('Current context:', currentContext);
            
            // Only use geometry type and dimensions for mesh preview
            const geometryType = currentContext.geometry_type || 'beam';
            const dimensions = currentContext.geometry_dimensions || { length: 1.0 };
            
            console.log('Geometry type:', geometryType);
            console.log('Dimensions:', dimensions);
            
            // Validate that we have minimum required data
            if (!geometryType || !dimensions || Object.keys(dimensions).length === 0) {
                console.log('Insufficient geometry data for mesh preview');
                // Don't destroy the iframe container, just show message in iframe
                const iframe = document.getElementById('meshIframe');
                if (iframe) {
                    iframe.src = 'data:text/html,<html><body style="display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; background: #001100; color: #ff6666; font-family: monospace; font-size: 18px;">Please provide geometry type and dimensions to generate mesh preview</body></html>';
                }
                return;
            }
            
            // Validate that dimensions have actual values (handle both strings and numbers)
            const hasValidValues = Object.values(dimensions).some(val => {
                if (val === null || val === undefined || val === '' || val === '0') return false;
                const numVal = typeof val === 'string' ? parseFloat(val.trim()) : val;
                return !isNaN(numVal) && numVal > 0;
            });
            if (!hasValidValues) {
                console.log('No valid dimension values found for geometry type:', geometryType);
                console.log('Dimensions:', dimensions);
                // Don't destroy the iframe container, just show message in iframe
                const iframe = document.getElementById('meshIframe');
                if (iframe) {
                    iframe.src = 'data:text/html,<html><body style="display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; background: #001100; color: #ff6666; font-family: monospace; font-size: 18px;">Please provide valid dimension values (greater than 0) for ' + geometryType + '</body></html>';
                }
                return;
            }
            
            // Don't show loading message - just update iframe directly when ready
            
            // Filter out null values from dimensions and convert strings to numbers
            const filteredDimensions = {};
            for (const [key, value] of Object.entries(dimensions)) {
                if (value !== null && value !== undefined && value !== '') {
                    // Convert string values to numbers
                    let numValue = value;
                    if (typeof value === 'string') {
                        const parsed = parseFloat(value.trim());
                        if (!isNaN(parsed) && parsed > 0) {
                            numValue = parsed;
                        } else {
                            continue; // Skip invalid values
                        }
                    } else if (typeof value === 'number' && value > 0) {
                        numValue = value;
                    } else {
                        continue; // Skip non-positive or invalid values
                    }
                    filteredDimensions[key] = numValue;
                }
            }
            
            // Create mesh preview request with only geometry data
            const geometryData = {
                geometry_type: geometryType,
                dimensions: filteredDimensions
            };
            
            console.log('Sending mesh preview request:', geometryData);
            
            fetch(`${window.location.origin}/mesh/preview`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(geometryData)
            })
            .then(response => {
                console.log('Mesh preview response status:', response.status);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Mesh preview response data:', data);
                if (data.success && data.mesh_visualization_url) {
                    console.log('Displaying mesh visualization:', data.mesh_visualization_url);
                    
                    // Mesh data is now handled by the FEniCS solver backend
                    // No need to store mesh data in frontend
                    
                    displayMeshVisualization(data.mesh_visualization_url);
                } else {
                    console.error('Mesh preview failed:', data.error || 'Unknown error');
                    const iframe = document.getElementById('meshIframe');
                    if (iframe) {
                        iframe.src = `data:text/html,<html><body style="display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; background: #001100; color: #ff6666; font-family: monospace; font-size: 18px;">Failed to generate mesh preview: ${data.error || 'Unknown error'}</body></html>`;
                    }
                }
            })
            .catch(error => {
                console.error('Error generating mesh preview:', error);
                const iframe = document.getElementById('meshIframe');
                if (iframe) {
                    iframe.src = `data:text/html,<html><body style="display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; background: #001100; color: #ff6666; font-family: monospace; font-size: 18px;">Error generating mesh preview: ${error.message}</body></html>`;
                }
            });
        }
        
        function displayMeshVisualization(url) {
            console.log('=== DISPLAYING MESH VISUALIZATION ===');
            console.log('URL:', url);
            
            // Only proceed if we have a valid URL
            if (!url) {
                console.log('No mesh visualization URL provided, skipping container creation');
                return;
            }
            
            const centerContent = document.getElementById('centerContent');
            console.log('Center content element:', centerContent);
            
            if (!centerContent) {
                console.error('Center content element not found');
                showStatus('error', 'Center content element not found');
                return;
            }
            
            // Clear any existing content first
            centerContent.innerHTML = '';
            
            // Replace the entire center content with a simple mesh container
            centerContent.innerHTML = `
                <div id="meshContainer" style="width: 100%; height: 100%; position: relative; background: #001100;">
                    <iframe id="meshIframe" style="width: 100%; height: 100%; border: 2px solid #00ff00; background: transparent; display: block;"></iframe>
                </div>
            `;
            
            const meshContainer = document.getElementById('meshContainer');
            console.log('Created mesh container:', meshContainer);
            
            // Update the iframe source
            const iframe = document.getElementById('meshIframe');
            console.log('Iframe element:', iframe);
            
            if (iframe) {
                console.log('Updating iframe src to:', url);
                iframe.src = url;
                
                // Add load event listeners for debugging
                iframe.onload = function() {
                    console.log('Mesh iframe loaded successfully:', url);
                    // Show success indicator
                    iframe.style.border = '2px solid #00ff00';
                };
                iframe.onerror = function() {
                    console.error('Mesh iframe failed to load:', url);
                    // Show error indicator
                    iframe.style.border = '2px solid #ff0000';
                    iframe.src = `data:text/html,<html><body style="display: flex; align-items: center; justify-content: center; height: 100vh; margin: 0; background: #001100; color: #ff6666; font-family: monospace; font-size: 18px; text-align: center;"><div><h3>Mesh Loading Failed</h3><p>URL: ${url}</p><p>Check console for details</p></div></body></html>`;
                };
                
                // Add a timeout to check if iframe loaded
                setTimeout(() => {
                    try {
                        const a = document.createElement('a');
                        a.href = url;
                        const expected = a.href; // normalized absolute URL
                        if (iframe.src === expected || iframe.src === url || iframe.src.startsWith('data:')) {
                            console.log('Iframe src set correctly');
                        } else {
                            console.warn('Iframe src normalized. Expected:', expected, 'Actual:', iframe.src);
                        }
                    } catch (e) {
                        console.warn('Iframe src check skipped:', e);
                    }
                }, 1000);
            } else {
                console.error('Could not find iframe element');
            }
            
            // Store the current visualization URL
            currentVisualizationUrl = url;
            
            console.log('Mesh iframe update completed');
        }
        
        function generateMeshPreview() {
            // This function is kept for backward compatibility but now redirects to center panel
            generateMeshPreviewInCenter();
        }
        
        function openInNewTab() {
            if (currentVisualizationUrl) {
                window.open(currentVisualizationUrl, '_blank');
            } else {
                // Generate a new mesh preview and open it in a new tab
                const geometryType = currentContext.geometry_type || 'beam';
                const dimensions = currentContext.geometry_dimensions || { length: 1.0 };
                
                if (geometryType && dimensions && Object.keys(dimensions).length > 0) {
                    const geometryData = {
                        geometry_type: geometryType,
                        dimensions: dimensions
                    };
                    
                    fetch(`${window.location.origin}/mesh/preview`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(geometryData)
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.mesh_visualization_url) {
                            window.open(data.mesh_visualization_url, '_blank');
                        }
                    })
                    .catch(error => {
                        console.error('Error generating mesh for new tab:', error);
                    });
                }
            }
        }
        
        // Store context when simulation results come back
        function storeSimulationContext(data) {
            if (data.success && data.context) {
                currentContext = data.context;
                console.log('Stored simulation context:', currentContext);
            }
        }
        
        function displayFieldVisualization(url) {
            console.log('=== DISPLAYING FIELD VISUALIZATION ===');
            console.log('URL:', url);
            
            if (!url) {
                console.error('No field visualization URL provided');
                showStatus('error', 'No field visualization URL');
                return;
            }
            
            const centerContent = document.getElementById('centerContent');
            console.log('Center content element:', centerContent);
            
            if (!centerContent) {
                console.error('Center content element not found');
                showStatus('error', 'Center content element not found');
                return;
            }
            
            // Clear any existing content first
            centerContent.innerHTML = '';
            
            // Replace the entire center content with a simple field container
            centerContent.innerHTML = `
                <div id="fieldContainer" style="width: 100%; height: 100%; position: relative; background: #001100;">
                    <iframe id="fieldIframe" style="width: 100%; height: 100%; border: 2px solid #00ff00; background: transparent; display: block;"></iframe>
                </div>
            `;
            
            const fieldContainer = document.getElementById('fieldContainer');
            console.log('Created field container:', fieldContainer);
            
            const iframe = document.getElementById('fieldIframe');
            console.log('Iframe element:', iframe);
            
            // Set the iframe source
            iframe.src = url;
            console.log('Updating iframe src to:', url);
            
            // Wait for iframe to load
            iframe.onload = function() {
                console.log('Field iframe loaded successfully:', url);
                showStatus('success', 'Field visualization loaded successfully.');
            };
            
            iframe.onerror = function() {
                console.error('Failed to load field visualization:', url);
                showStatus('error', 'Failed to load field visualization.');
            };
        }
        
        function reloadVisualization() {
            if (currentVisualizationUrl) {
                const iframe = document.getElementById('meshIframe');
                if (iframe) {
                    iframe.src = 'about:blank';
                    setTimeout(() => {
                        iframe.src = `${currentVisualizationUrl}?t=${Date.now()}`;
                    }, 100);
                }
            }
        }
        
        function openFullScreen() {
            if (currentVisualizationUrl) {
                const fullscreenWindow = window.open(currentVisualizationUrl + '?fullscreen=true', '_blank', 
                    'width=1400,height=900,scrollbars=no,resizable=yes,menubar=no,toolbar=no,location=no,status=no');
                
                if (fullscreenWindow) {
                    // Focus the new window
                    fullscreenWindow.focus();
                }
            }
        }
        
        function toggleSize() {
            const iframe = document.getElementById('meshIframe');
            if (iframe) {
                const currentHeight = iframe.style.height;
                if (currentHeight === '100%') {
                    iframe.style.height = '400px';
                } else {
                    iframe.style.height = '100%';
                }
            }
        }
        
        // Allow Enter key to submit
        document.getElementById('prompt').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                simulate();
            }
        });
        
        // Boundary condition update functions
        function updateBoundaryConditionType(index, newType) {
            if (!window.currentContext || !window.currentContext.boundary_conditions) return;
            
            const bc = window.currentContext.boundary_conditions[index];
            if (!bc) return;
            
            // Update the boundary condition type
            bc.type = newType;
            bc.bc_type = newType;
            
            // CRITICAL: Mark this boundary condition as user-modified
            // Remove placeholder flags and add user_modified flag
            bc.is_placeholder = false;
            bc.is_user_modified = true;
            bc.source = 'user';
            
            // CRITICAL: Update window.currentContext to keep it in sync
            if (!window.currentContext) {
                window.currentContext = {};
            }
            if (!window.currentContext.boundary_conditions) {
                window.currentContext.boundary_conditions = [];
            }
            // Ensure the BC in window.currentContext is also updated
            const windowBc = window.currentContext.boundary_conditions[index];
            if (windowBc) {
                windowBc.type = newType;
                windowBc.bc_type = newType;
                windowBc.is_placeholder = false;
                windowBc.is_user_modified = true;
                windowBc.source = 'user';
            }
            
            console.log(`Updated boundary condition ${index} type: ${newType} (marked as user-modified)`);
            
            // Immediately refresh UI to show the change
            refreshRightPanel();
            
            // Update PDE config in background (this will persist to backend)
            updatePdeConfigFromContext();
            
            // Also parse the boundary condition change (for AI classification)
            parseBoundaryConditionChange(bc);
            
            // CRITICAL: Update button visibility after BC type change
            setTimeout(() => {
                updateButtonVisibility();
            }, 150);
        }
        
        function parseVectorValue(input) {
            /**
             * Parse vector input in multiple formats:
             * - [x, y, z] or [x,y,z]
             * - (x, y, z) or (x,y,z)
             * - {x, y, z} or {x,y,z}
             * - x, y, z (comma-separated)
             * Supports scientific notation: 1e6, 1.5e-3, etc.
             * Returns array of numbers or null if not a valid vector
             */
            if (typeof input !== 'string') {
                return null;
            }
            
            const trimmed = input.trim();
            if (!trimmed) return null;
            
            // Try to match bracketed formats: [x,y,z], (x,y,z), {x,y,z}
            // Updated pattern to support scientific notation and negative numbers
            const bracketPattern = /^[\[\(\{]\s*([-\d\.eE\+\s,]+)\s*[\]\)\}]$/;
            const bracketMatch = trimmed.match(bracketPattern);
            
            let components;
            if (bracketMatch) {
                // Extract content inside brackets
                components = bracketMatch[1];
            } else if (trimmed.includes(',')) {
                // Comma-separated format: x, y, z
                components = trimmed;
            } else {
                // Not a vector format
                return null;
            }
            
            // Split by comma and parse each component
            // Handle scientific notation and negative numbers
            const parts = components.split(',').map(s => s.trim()).filter(s => s !== '');
            if (parts.length < 2) {
                // Need at least 2 components for a vector
                return null;
            }
            
            const numbers = parts.map(p => {
                // Handle scientific notation: 1e6, 1.5e-3, etc.
                return parseFloat(p);
            });
            
            // Check if all components are valid numbers
            if (numbers.length >= 2 && numbers.every(n => !isNaN(n) && isFinite(n))) {
                return numbers;
            }
            
            return null;
        }
        
        function updateBoundaryConditionValue(index, newValue) {
            if (!window.currentContext || !window.currentContext.boundary_conditions) return;
            
            const bc = window.currentContext.boundary_conditions[index];
            if (!bc) return;
            
            // First, try to parse as vector (for traction, displacement, etc.)
            const vectorValue = parseVectorValue(newValue);
            if (vectorValue !== null) {
                // Valid vector input
                bc.value = vectorValue;
                bc.is_placeholder = false;
                bc.is_user_modified = true;
                bc.source = 'user';
                console.log(`Updated boundary condition ${index} to vector: ${newValue} -> [${vectorValue.join(', ')}]`);
                refreshRightPanel();
                updatePdeConfigFromContext();
                parseBoundaryConditionChange(bc);
                return;
            }
            
            // Fall back to scalar parsing (existing logic)
            let parsedValue;
            if (typeof newValue === 'string' && newValue.trim() !== '') {
                // Try to parse as number first (handles "10", "10.5", etc.)
                parsedValue = parseFloat(newValue);
                // If that fails, try parseConfigInput for units like "10kN", "100°C"
                if (isNaN(parsedValue)) {
                    parsedValue = parseConfigInput('force', newValue);
                    parsedValue = parseFloat(parsedValue);
                }
            } else if (typeof newValue === 'number') {
                parsedValue = newValue;
            } else {
                parsedValue = 0;
            }
            
            // Only update if we have a valid number
            if (!isNaN(parsedValue)) {
                bc.value = parsedValue;
                
                // CRITICAL: Mark this boundary condition as user-modified
                // Remove placeholder flags and add user_modified flag
                bc.is_placeholder = false;
                bc.is_user_modified = true;
                bc.source = 'user';
                
                console.log(`Updated boundary condition ${index} value: ${newValue} -> ${bc.value} (marked as user-modified)`);
                
                // Immediately refresh UI to show the change
                refreshRightPanel();
                
                // Update PDE config in background (this will persist to backend)
                updatePdeConfigFromContext();
                
                // Also parse the boundary condition change (for AI classification)
                parseBoundaryConditionChange(bc);
            } else {
                console.warn(`Could not parse boundary condition value: ${newValue}`);
            }
        }
        
        function getBoundaryConditionOptions(physicsType) {
            const options = {
                'heat_transfer': [
                    { value: 'temperature', text: 'Temperature' },
                    { value: 'heat_flux', text: 'Heat Flux' },
                    { value: 'insulated', text: 'Insulated' }
                ],
                'solid_mechanics': [
                    { value: 'fixed', text: 'Fixed' },
                    { value: 'free', text: 'Free' },
                    { value: 'traction', text: 'Traction' },
                    { value: 'pressure', text: 'Pressure' }
                ]
            };
            
            return options[physicsType] || options['heat_transfer'];
        }
        
        function normalizeBcType(physicsType, bc) {
            const raw = (bc && (bc.type || bc.bc_type)) || '';
            if (!raw) return raw;
            const s = String(raw).toLowerCase().trim();
            if (physicsType === 'heat_transfer') {
                if (s === 'neumann' || s === 'flux' || s === 'heat flux') return 'heat_flux';
                if (s === 'dirichlet' || s === 'fixed' || s === 'temperature') return 'temperature';
                if (s === 'insulated' || s === 'neumann_zero') return 'insulated';
            } else if (physicsType === 'solid_mechanics') {
                if (s === 'dirichlet' || s === 'fixed' || s === 'displacement') return 'fixed';
                if (s === 'neumann' || s === 'traction') return 'traction';
                if (s === 'pressure') return 'pressure';
                if (s === 'free' || s === 'roller') return 'free';
            }
            return s;
        }

        function generateBoundaryConditionSelect(bc, index, physicsType) {
            const options = getBoundaryConditionOptions(physicsType);
            const normType = normalizeBcType(physicsType, bc);
            let selectHtml = '<select class="config-input" onchange="updateBoundaryConditionType(' + index + ', this.value)">';
            
            options.forEach(option => {
                const selected = normType === option.value ? 'selected' : '';
                selectHtml += `<option value="${option.value}" ${selected}>${option.text}</option>`;
            });
            
            selectHtml += '</select>';
            return selectHtml;
        }
        
        function removeBoundaryCondition(index) {
            if (!window.currentContext || !window.currentContext.boundary_conditions) return;
            
            // Remove the boundary condition
            window.currentContext.boundary_conditions.splice(index, 1);
            
            // Refresh the right panel to show updated boundary conditions
            refreshRightPanel();
        }
        
        function parseBoundaryConditionChange(bc) {
            // Create a prompt for AI to parse the boundary condition change at the specific location
            const location = bc.location || bc.mapped_location || 'unknown';
            const prompt = `Boundary condition at ${location}: ${bc.type} = ${bc.value}. Parse this boundary condition and ensure it's correctly classified.`;
            
            console.log('Parsing boundary condition change:', prompt);
            console.log('Boundary condition object:', bc);
            
            // Send to AI for parsing (this will update the boundary condition classification)
            parseBoundaryConditionPrompt(prompt, bc);
            
            // Also update the pde_config with the current context
            updatePdeConfigFromContext();
        }
        
        async function updatePdeConfigFromContext() {
            try {
                console.log('Updating pde_config from current context...');
                
                const response = await fetch(`${window.location.origin}/update_boundary_condition`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        boundary_condition: {}, // Not needed for context update
                        context: window.currentContext
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        console.log('Successfully updated pde_config:', result.updated_pde_config);
                        showStatus('success', 'Boundary conditions updated in PDE configuration');
                    } else {
                        console.error('Failed to update pde_config:', result.error);
                        showStatus('error', 'Failed to update PDE configuration');
                    }
                } else {
                    console.error('Error updating pde_config: HTTP', response.status);
                    showStatus('error', 'Error updating PDE configuration');
                }
            } catch (error) {
                console.error('Error updating pde_config:', error);
                showStatus('error', 'Error updating PDE configuration');
            }
        }
        
        async function parseBoundaryConditionPrompt(prompt, bc) {
            try {
                // Send the boundary condition change to the AI parser
                const response = await fetch(`${window.location.origin}/parse_boundary_condition`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        boundary_condition: bc,
                        context: window.currentContext
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.boundary_condition) {
                        // Update the boundary condition with AI-parsed information
                        Object.assign(bc, result.boundary_condition);
                        
                        // Refresh the right panel to show updated boundary conditions
                        refreshRightPanel();
                        
                        console.log('Boundary condition updated by AI:', bc);
                    }
                }
            } catch (error) {
                console.error('Error parsing boundary condition:', error);
            }
        }
        
        // Focus on prompt input on page load
        window.addEventListener('load', function() {
            document.getElementById('prompt').focus();
            
            // Don't initialize mesh container on load - keep the placeholder
            // The placeholder will be replaced when mesh visualization is available
            // Only initialize if there's already mesh data (shouldn't happen on fresh load)
            const centerContent = document.getElementById('centerContent');
            if (centerContent && !document.getElementById('meshContainer')) {
                // Keep the initial placeholder HTML - don't replace with empty iframe
                console.log('Center panel initialized with placeholder');
            }
        });
    </script>
</body>
</html>
